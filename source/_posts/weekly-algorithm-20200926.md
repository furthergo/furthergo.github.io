---
title: weekly-algorithm-20200926
tags:
  - algorithm
categories:
  - Weekly Algorithm
keywords:
  - Ones And Zeros
  - Predict the Winner
  - Target Sum
  - Longest Palindromic Subsequence
  - Out of Boundary Paths - Minimax - Dynamic Programming - knapsack Algorithm
date: 2020-09-25 22:12:14
---


# æ€»ç»“
æœ¬å‘¨ä¸€å…±åˆ·äº†5é“mediumï¼Œå·©å›ºäº†ä¸€ä¸‹èƒŒåŒ…ç®—æ³•ï¼Œä»¥åŠäº†è§£äº†ä¸€ä¸‹Minimaxç®—æ³•çš„å«ä¹‰å’Œä½¿ç”¨åœºæ™¯ã€‚

# [Ones And Zeros](https://leetcode.com/problems/ones-and-zeroes/)
```
ç»™ä¸€ä¸ªå­—ç¬¦ä¸²æ•°ç»„strsï¼Œå…¶ä¸­çš„å­—ç¬¦ä¸²åªåŒ…å«'0'æˆ–è€…'1'ï¼Œè¾“å…¥må’Œnåˆ†åˆ«ä»£è¡¨å¯ä»¥ä½¿ç”¨çš„0å’Œ1çš„ä¸ªæ•°ï¼Œé—®è¿™mä¸ª0å’Œnä¸ª1ï¼Œæœ€å¤šèƒ½ä»æ•°ç»„é‡Œå–å‡ºå¤šå°‘ä¸ªå­—ç¬¦ä¸²æ¥ç»„æˆï¼Ÿ

æ¯”å¦‚è¾“å…¥ï¼šstrs = ["10","0001","111001","1","0"], m = 5, n = 3
è¾“å‡ºï¼š 4
è§£é‡Š: ç”¨5ä¸ª0å’Œ3ä¸ª1æœ€å¤šå¯ä»¥å–å‡º"10","0001","1","0"å››ä¸ªå­—ç¬¦ä¸²
```
## åˆ†æ
è¿™æ˜¯ä¸€é“å…¸å‹çš„èƒŒåŒ…é—®é¢˜ï¼Œå’Œé‚£é“å–ç¡¬å¸çš„é¢˜ç±»ä¼¼ï¼ŒåŒºåˆ«åœ¨äºèƒŒåŒ…é—®é¢˜åªæœ‰é‡é‡ä¸€ä¸ªé™åˆ¶ï¼Œå‡å¦‚é™åˆ¶é‡é‡æ˜¯Cï¼Œå¯ä»¥çœ‹åšæ˜¯Cä¸ª1ã€‚è€Œè¿™é“é¢˜æ˜¯æœ‰0å’Œ1ä¸¤ä¸ªé™åˆ¶ï¼Œç›¸æ¯”äºèƒŒåŒ…é—®é¢˜å¤šäº†ä¸€ä¸ªç»´åº¦ï¼Œä½†æ˜¯è§£é¢˜çš„æ€è·¯è¿˜æ˜¯ç±»ä¼¼çš„ã€‚

ç±»æ¯”èƒŒåŒ…é—®é¢˜çš„è§£é¢˜æ€è·¯ï¼Œæˆ‘ä»¬ç”¨ä¸€ä¸ªä¸‰ç»´æ•°ç»„æ¥å­˜å‚¨å–åˆ°ç¬¬iä¸ªå­—ç¬¦ä¸²æ—¶ï¼Œæ¶ˆè€—jä¸ª0å’Œkä¸ª1æœ€å¤šèƒ½å–åˆ°å­—ç¬¦ä¸²çš„ä¸ªæ•°ï¼Œè®°ä½œf(i, j, k)ã€‚åˆ™æœ‰çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š
<center>
f(i, j, k) = max(f(i-1, j, k), f(i-1, j - zero(strs[i]), k - one(strs[i]))))

å…¶ä¸­zero(strs[i])å’Œone(strs[i])åˆ†åˆ«ä»£è¡¨ç¬¬iä¸ªå­—ç¬¦ä¸²åŒ…å«çš„0å’Œ1çš„ä¸ªæ•°
</center>

## å®ç°

æ ¹æ®ä¹‹å‰å¸¸ç”¨çš„ä¼˜åŒ–ç©ºé—´å¤æ‚åº¦çš„å¥—è·¯ï¼Œè§‚å¯ŸçŠ¶æ€è½¬ç§»æ–¹ç¨‹å¯ä»¥çœ‹å‡ºï¼š
1. f(i, j, k)åªä¾èµ–f(i-1)çš„çŠ¶æ€ï¼Œæ‰€ä»¥å¯ä»¥ä¼˜åŒ–dpä¸ºäºŒç»´æ•°ç»„;
2. åªæœ‰å½“jå¤§äºç­‰äºå½“å‰0çš„ä¸ªæ•°ï¼Œä¸”kå¤§äºç­‰äºå½“å‰1çš„ä¸ªæ•°æ—¶ï¼Œæ‰æœ‰ç¬¬äºŒç§å¯èƒ½ï¼Œå¦åˆ™f(i,j,k)=f(i-1,j,k)ï¼Œå³ä¸éœ€è¦æ›´æ–°;
3. æ ¹æ®2å¯ä»¥å¾—å‡ºï¼Œæˆ‘ä»¬åªéœ€è¦éå†jå’Œkåˆ°å½“å‰å­—ç¬¦ä¸²çš„0å’Œ1çš„ä¸ªæ•°å¤„å³å¯

å®ç°å¦‚ä¸‹ï¼š
```golang

func zerosAndOnes(str string) (z, o int) {
	l := len(str)
	for _, v := range str {
		if v == '0' {
			z++
		}
	}
	return z, l - z
}
func findMaxForm(strs []string, m int, n int) int {
	l := len(strs)
	if l == 0 {
		return 0
	}
	dp := make([][]int, m+1)
	for i := 0; i <= m; i++ {
		dp[i] = make([]int, n+1)
	}
	for i := 0; i < l; i++ {
		z, o := zerosAndOnes(strs[i])
		for j := m; j >= z; j-- {
			for k := n; k >= o; k-- {
				if (dp[j-z][k-o] + 1) > dp[j][k] {
					dp[j][k] = dp[j-z][k-o] + 1
				}
			}
		}
	}
	return dp[m][n]
}
```



# [Predict the Winner](https://leetcode.com/problems/predict-the-winner/)
```
ç»™å®šä¸€ä¸ªåªåŒ…å«éè´Ÿæ•´æ•°çš„æ•°ç»„ï¼Œæœ‰ä¸¤ä¸ªäººä¼šä¾æ¬¡äº¤æ›¿ä»è¿™ä¸ªæ•°ç»„çš„ä¸¤ç«¯ä»»æ„å–èµ°ä¸€ä¸ªæ•°å­—ï¼Œå–èµ°çš„åŸåˆ™æ˜¯æœ€åè‡ªå·±èƒ½å–åˆ°çš„æ‰€æœ‰çš„æ•°çš„å’Œæ¯”å¦ä¸€ä¸ªäººå–èµ°çš„æ•°çš„å’Œæ›´å¤§ã€‚å‡è®¾ä¸¤ä¸ªäººéƒ½èƒ½åšå‡ºæœ€ä¼˜çš„åˆ¤æ–­ï¼Œé—®å…ˆå–çš„äººæœ€åèƒ½å¦å–å¾—èƒœåˆ©ï¼Ÿ

æ¯”å¦‚ï¼š
è¾“å…¥: [1, 5, 2]
è¾“å‡º: false
è§£é‡Š: å› ä¸ºç¬¬ä¸€ä¸ªäººå–èµ°1æˆ–è€…2ä¹‹åï¼Œç¬¬äºŒä¸ªäººä¼šå–5ï¼Œ5 > 2 + 1ï¼Œæ‰€ä»¥ç¬¬ä¸€ä¸ªäººä¼šè¾“
```

## åˆ†æï¼šé€’å½’è§£æ³•
æœ€ç›´è§‚çš„æƒ³è¿™é“é¢˜ï¼Œæˆ‘éœ€è¦é€‰æ‹©çš„æ•°æœ€åå’Œå°½å¯èƒ½å¤§ï¼Œé‚£å°±æ˜¯æ˜¯è®©å¦ä¸€ä¸ªäººå¯é€‰æ‹©çš„æ•°çš„å’Œå°½å¯èƒ½çš„å°ï¼Œå¯ä»¥ç”¨é€’å½’æ±‚è§£ã€‚

1. å¯¹äºç¬¬ä¸€ä¸ªäººçš„æ¯ä¸€æ¬¡é€‰æ‹©æ¥è¯´ï¼Œæœ‰ä¸¤ç§é€‰æ³•ï¼šé€‰æ‹©å½“å‰å‰©ä¸‹çš„æ•°çš„ç¬¬ä¸€ä¸ªæ•°æˆ–è€…æœ€åä¸€ä¸ªæ•°ï¼›
2. åº”è¯¥é€‰å“ªä¸ªæ•°çš„åŸåˆ™ï¼Œæ˜¯è®©å¦ä¸€ä¸ªäººåœ¨å‰©ä¸‹çš„æ•°ä¸­èƒ½**é€‰æ‹©çš„æ•°çš„æœ€å¤§å’Œ**å°½å¯èƒ½å°ã€‚
3. å‡å¦‚å½“å‰åœ¨indexä¸ºiåˆ°jçš„èŒƒå›´å†…é€‰ï¼Œé€‰æ‹©indexä¸ºiçš„æ•°ï¼Œé‚£ä¹ˆå¦ä¸€ä¸ªäººå°±æ˜¯èƒ½åœ¨i+1åˆ°jçš„èŒƒå›´é€‰æ‹©ï¼›é€‰æ‹©indexä¸ºjçš„æ•°ï¼Œé‚£ä¹ˆå¦ä¸€ä¸ªäººå°±æ˜¯èƒ½åœ¨iåˆ°j-1çš„èŒƒå›´é€‰æ‹©ï¼›
4. å½“å¦ä¸€ä¸ªäººä»i+1åˆ°jæˆ–è€…iåˆ°j-1é€‰æ‹©çš„æ—¶å€™ï¼Œä»ä»–çš„è§†è§’çœ‹ï¼Œä»–è¿˜æ˜¯ä¼šé‡å¤1-3çš„æ­¥éª¤
5. å¯¹äºç¬¬ä¸€ä¸ªäººæ¥è¯´ï¼Œå¦ä¸€ä¸ªäººçš„ä¸¤ç§é€‰æ‹©

æˆ‘ä»¬ç”¨f(i, j)ä»£è¡¨å½“å‰é€‰æ‹©çš„äººï¼Œèƒ½ä»æ•°ç»„çš„indexä¸ºiåˆ°indexä¸ºjçš„å­æ•°ç»„é‡Œï¼Œèƒ½å–åˆ°æ•°çš„å’Œçš„æœ€å¤§å€¼ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥æ¨æ–­å‡º`f(i, j) = sum(i, j) - min(f(i+1, j), f(i, j-1))`ï¼Œæˆ‘ä»¬å¯¹f(i, j)é€’å½’æ±‚è§£ï¼Œç›´åˆ°æ•°æ®é‡Œåªæœ‰ä¸¤ä¸ªæ•°çš„æ—¶å€™ï¼Œä¸€å®šæ˜¯é€‰æ›´å¤§çš„é‚£ä¸€ä¸ªã€‚

## é€’å½’å®ç°
```golang
func max(a int, b int) int {
	if a > b {
		return a
	}
	return b
}
func maxPickSum(sum int, nums []int) int {
	n := len(nums)
	if n == 0 {
		return 0
	}
	if n == 1 {
		return nums[0]
	}
	if n == 2 {
		return max(nums[0], nums[1])
	}

	t1 := sum - maxPickSum(sum-nums[0], nums[1:])
	t2 := sum - maxPickSum(sum-nums[n-1], nums[:n-1])
	return max(t1, t2)
}
func PredictTheWinner(nums []int) bool {
	sum := 0
	for _, v := range nums {
		sum += v
	}
	m := maxPickSum(sum, nums)
	if m*2 >= sum {
		return true
	}
	return false
}
```
æ³¨æ„è¿™é‡Œéœ€è¦æœ‰ä¸€ä¸ªsumå˜é‡ä»£è¡¨å½“å‰çš„æ€»å’Œï¼Œå¹¶ä¸”ä¸æ–­æ›´æ–°ã€‚

ä¸€å¼€å§‹ä»¥ä¸ºé€’å½’è§£æ³•ä¼šè¶…æ—¶ï¼Œæ²¡æƒ³åˆ°å°è¯•æäº¤äº†ä¸€äº›å±…ç„¶è¿‡äº†ï¼Œä½†æ˜¯æœ‰ç‚¹æ…¢ï¼Œæˆ‘ä»¬å†ä»DPçš„è§’åº¦æ±‚è§£ã€‚

## åˆ†æï¼šDPè§£æ³•
è¿˜æ˜¯ä¸Šé¢æ¨å¯¼å‡ºçš„ç­‰å¼ `f(i, j) = sum(i, j) - min(f(i+1, j), f(i, j-1))`ã€‚

* å¾ˆæ˜æ˜¾çš„å¯ä»¥çœ‹åˆ°å‡å¦‚æˆ‘ä»¬ç”¨ä¸€ä¸ªæ•°ç»„å­˜å‚¨f(i, j)ã€‚
* æ³¨æ„è¿™é“é¢˜æœ‰ä¸€ç‚¹ä¸ä¸€æ ·çš„æ˜¯ï¼Œf(i, j)ä¾èµ–çš„æ˜¯f(i+1,j)ï¼Œæ‰€ä»¥åœ¨éå†æ±‚è§£dpçš„æ—¶å€™ï¼Œéœ€è¦æœ€åä¸€è¡Œå¼€å§‹å¾€ä¸Šéå†ã€‚
* å†è§‚å¯Ÿä¸€ä¸‹ï¼Œf(i, j) åªä¾èµ–å½“å‰è¡Œæˆ–è€…åä¸€è¡Œï¼Œå¸¸è§å¥—è·¯ï¼Œç©ºé—´å¤æ‚åº¦å¯ä»¥ä¼˜åŒ–åˆ°O(n)
* æ³¨æ„è¿™é‡Œä¾èµ–

## DPå®ç°
```golang

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func PredictTheWinner(nums []int) bool {
	n := len(nums)
	dp := make([]int, n)
	sum := 0
	dp[n-1] = nums[n-1]
	for i := n - 2; i >= 0; i-- {
		dp[i] = nums[i]
		sum = nums[i]
		for j := i + 1; j < n; j++ {
			sum += nums[j]
			// çŠ¶æ€è½¬ç§»æ–¹ç¨‹
			// dp[i][j] = sum[i][j] - min(dp[i][j-1], dp[i+1][j])
			dp[j] = sum - min(dp[j-1], dp[j])
		}
	}
	return dp[n-1]*2 >= sum
}
```

åŒæ ·çš„ï¼Œè¿™é‡Œéœ€è¦sumå˜é‡ï¼Œä»£è¡¨å½“å‰sum(i, j)ã€‚iç­‰äºn-1æ—¶ï¼Œåªæœ‰ä¸€ä¸ªæ•°å°±æ˜¯nums[n-1]ï¼Œæ‰€ä»¥dp[n-1]=nums[n-1]ã€‚ç„¶åiä»n-2å³æœ€åä¸€è¡Œå¼€å§‹éå†ã€‚

# [Target Sum](https://leetcode.com/problems/target-sum/)
```
ç»™å®šä¸€ä¸ªä¸åŒ…å«è´Ÿæ•°çš„æ•´æ•°æ•°ç»„ï¼Œå’Œä¸€ä¸ªç›®æ ‡å€¼Sï¼Œç”¨æ•°ç»„é‡Œçš„æ¯ä¸€ä¸ªæ•°åŠ æƒæ±‚å’Œï¼Œé—®æœ‰å¤šå°‘ç§åŠ æƒçš„æ–¹å¼æœ€åå’Œä¸ºSï¼Ÿè¿™é‡Œæ¯ä¸ªæ•°éƒ½å¯ä»¥åŠ +1æˆ–è€…-1çš„æƒã€‚

æœ‰ä¸€äº›æ¡ä»¶é™åˆ¶ï¼š
1. æ•°ç»„é•¿åº¦ä¸è¶…è¿‡20
2. æ•°ç»„çš„å…ƒç´ ä¹‹å’Œä¸è¶…è¿‡1000


æ¯”å¦‚è¾“å…¥ï¼š [1, 1, 1, 1, 1], S æ˜¯ 3
è¾“å‡º: 5
è§£é‡Š: 
-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3
å…±æœ‰5ä¸­åŠ æƒæ–¹å¼ã€‚
```

## åˆ†æ
åˆåŒå’å•æ˜¯ä¸€é“èƒŒåŒ…çš„é¢˜å‹ï¼š
```
ä»æ•°ç»„ä¸­ä»¥æŸç§å§¿åŠ¿é€‰æ‹©å…ƒç´ ï¼Œç„¶åä»¥æŸç§å§¿åŠ¿ç»„æˆä¸€ä¸ªæœ‰é™åˆ¶çš„è¾“å‡ºã€‚
é—®ï¼šä¸€å…±æœ‰å¤šå°‘ç§å¯èƒ½çš„å§¿åŠ¿ï¼Ÿ
```

* å¸¸è§çš„æ€è·¯ï¼Œå°±æ˜¯æ±‚è§£å–åˆ°ç¬¬iä¸ªå…ƒç´ æ—¶ï¼Œç»„æˆjçš„å¯èƒ½çš„å§¿åŠ¿çš„ä¸ªæ•°ï¼Œè€Œè¿™ä¸ªä¸ªæ•°å¾€å¾€å¯ä»¥ç”±åˆ°i-1çš„æŸä¸ªjçš„ä¸ªæ•°å†³å®šï¼Œæˆ‘ä»¬åªéœ€è¦éå†ä»ç¬¬ä¸€ä¸ªå…ƒç´ åˆ°æœ€åä¸€ä¸ªå…ƒç´ ï¼›
* æ¯”å¦‚è¿™é“é¢˜ï¼Œç›®æ ‡å€¼æ˜¯Sï¼Œæ¯ä¸ªæ•°å¯ä»¥åŠ +1æƒæˆ–è€…-1æƒç«‹åˆ»å¯ä»¥å¾—å‡ºç­‰å¼ï¼š`f(i, j) = f(i-1, j-nums[i]) + f(i-1, j+nums[i])`

ä½†æ˜¯ï¼Œæ³¨æ„è¿™é“é¢˜ï¼ŒåŠ æƒæ˜¯æ­£æˆ–è€…è´Ÿï¼Œä¹Ÿå°±æ˜¯è¯´:
```
ä¹‹å‰çš„æ•°çš„å’Œå¯èƒ½å­˜åœ¨è´Ÿæ•°ï¼Œè€Œè´Ÿæ•°æ˜¯ä¸èƒ½ä½œä¸ºæ•°ç»„ä¸‹æ ‡çš„
```

ä¸ºäº†ç»§ç»­ä½¿ç”¨DPï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°é¢˜ç›®æœ‰ä¸ªé™åˆ¶æ˜¯**æ•°ç»„çš„æ‰€æœ‰å…ƒç´ å’Œä¸è¶…è¿‡1000**ï¼Œå°±è¡¨ç¤ºæœ€å°çš„å’Œæ˜¯-1000ï¼ˆæ‰€æœ‰çš„æƒéƒ½æ˜¯-1ï¼‰ã€‚æˆ‘ä»¬å¯ä»¥ç»™æ•°ç»„ä¸‹æ ‡åŠ ä¸ª1000çš„åç§»ï¼Œ0ä»£è¡¨å’Œä¸º-1000ï¼Œ 1000ä»£è¡¨0ï¼Œ2000ä»£è¡¨1000â€¦ jä»£è¡¨å’Œä¸ºj-1000

## å®ç°
ç”¨dp[i][j]ä»£è¡¨æ•°ç»„ä»0-içš„èŒƒå›´å†…ï¼Œèƒ½ç»„æˆå’Œä¸ºj-1000çš„å¯èƒ½çš„æ–¹å¼ï¼Œåˆ™`dp[i][j] = dp[i-1][j-nums[i]] + dp[i-1][j+nums[i]]`ã€‚
* æ³¨æ„è¿™é‡Œjçš„èŒƒå›´æ˜¯0åˆ°1000*2ï¼Œæ‰€ä»¥éœ€è¦åˆ¤æ–­å½“å‰çš„j-nums[i]å’Œj+nums[i]åœ¨è¿™ä¸ªèŒƒå›´å†…ã€‚
* ç”±äºåªä¾èµ–dp[i-1]ï¼Œä¼˜åŒ–ä¸ºä¸¤ä¸ªä¸€ä½æ•°ç»„ï¼ŒO(n)çš„ç©ºé—´å¤æ‚åº¦

å®ç°ä»£ç å¦‚ä¸‹ï¼š
```golang
func findTargetSumWays(nums []int, S int) int {
    MAXS := 1000
    if S >  MAXS || S < -MAXS {
        return 0
    }
    n := len(nums)
    dp := make([]int, MAXS*2+1)
    preDp := make([]int, MAXS*2+1)
    
    preDp[MAXS] = 1
    
    for i := 1; i<=n; i++ {
        for j := 0; j<=MAXS*2; j++ {
            // dp[i][j]ä»£è¡¨ä»0-iï¼Œèƒ½ç»„æˆå’Œä¸ºj-1000çš„æ‰€æœ‰å¯èƒ½çš„ä¸ªæ•°
            // ç­‰äºä»0-i-1ï¼Œèƒ½ç»„æˆå’Œä¸ºj-1000-nums[i]çš„ä¸ªæ•°åŠ ä¸Šèƒ½ç»„æˆå’Œä¸ºj-1000+nums[i]çš„ä¸ªæ•°
            // å³ j-1000-nums[i]çš„ä¸ªæ•°ç­‰äºdp[i-1][j-1000-nums[i]+1000] = dp[i-1][j-nums[i]]
            // å³çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š dp[i][j] = dp[i-1][j-nums[i-1]] + dp[i-1][j+nums[i-1]]
            // é˜²æ­¢è¶Šç•Œ
            // ä¼˜åŒ–ç©ºé—´å¤æ‚åº¦
            if j >= nums[i-1] {
                dp[j] = preDp[j-nums[i-1]]
            }
            if j + nums[i-1] <=MAXS*2 {
                dp[j] += preDp[j+nums[i-1]]
            }
        }
        for j := 0; j<=MAXS*2; j++ {
            preDp[j] = dp[j]
        }
    }
    return dp[S+1000]
}
```

è¿™é‡Œå½“Sè¶…è¿‡äº†æœ€å¤§æˆ–æœ€å°çš„å¯èƒ½æ—¶ï¼Œç›´æ¥è¿”å›0ã€‚

# [Longest Palindromic Subsequence](https://leetcode.com/problems/longest-palindromic-subsequence/)
```
ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²strï¼Œæ±‚è¿™ä¸ªå­—ç¬¦ä¸²çš„æœ€é•¿å›æ–‡å­åºåˆ—çš„é•¿åº¦æ˜¯å¤šå°‘ï¼Ÿ
æ¯”å¦‚è¾“å…¥bbbab
è¾“å…¥ï¼š4
æœ€é•¿å›æ–‡å­åºåˆ—æ˜¯bbbb
```

## åˆ†æ
DPç»å…¸é¢˜ç›®ï¼Œæœ€é‡è¦çš„è¿˜æ˜¯å¯»æ‰¾çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼Œæˆ‘ä»¬ç”¨`s(i,j)ä»£è¡¨å­—ç¬¦ä¸²ä»index iåˆ°jçš„èŒƒå›´å†…æœ€é•¿å›æ–‡å­åºåˆ—`ï¼Œ`f(i,j)ä»£è¡¨s(i,j)çš„é•¿åº¦`ï¼Œä¸‹é¢æ¥åˆ†ææ±‚è§£s(i,j)å’Œf(i,j)çš„è¿‡ç¨‹

1. å‡å¦‚`str[i]==str[j]`ï¼Œé‚£ä¹ˆè¡¨ç¤ºå¯¹äºè¦æ±‚çš„s(i,j)ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨s(i+1,j-1)çš„ä¸¤ç«¯åˆ†åˆ«æ·»åŠ str[i]å’Œstr[j]ï¼Œè¿™æ ·èƒ½ç»„æˆæœ€é•¿å›æ–‡å­åºåˆ—å³s(i,j)
2. å¯ä»¥å¾—å‡ºä»iåˆ°jçš„å­—ç¬¦ä¸²çš„æœ€é•¿å›æ–‡å­åºåˆ—çš„é•¿åº¦ `f(i,j) = f(i+1,j-1) + 2`

ä»¥ä¸Šæ˜¯str[i]==str[j]çš„æƒ…å†µï¼Œå‡å¦‚str[i] != str[j]å‘¢ï¼Ÿ

3. å³å¯¹äºæˆ‘ä»¬è¦æ±‚çš„s(i, j)æ¥è¯´ï¼Œç”±äº`str[i] != str[j]`ï¼Œé‚£ä¹ˆ`ä¸å¯èƒ½åŒæ—¶åœ¨s(i+1,j-1)çš„ä¸¤ç«¯æ·»åŠ str[i]å’Œstr[j]`æ¥æ„æˆs(i,j)
4. è¦ä¹ˆstr[i]æ·»åŠ è¿›s(i+1,j-1)çš„å·¦è¾¹ï¼Œè¦ä¹ˆstr[j]æ·»åŠ è¿›s(i+1,j-1)çš„å³è¾¹ï¼ŒåŒæ—¶æˆ‘ä»¬ä¸çŸ¥é“è¿™ç§æ·»åŠ æ˜¯å¦ä¼šç ´ås(i+1,j-1)çš„å›æ–‡ç‰¹æ€§ï¼Œæ‰€ä»¥ä¸èƒ½ç›´æ¥ç”¨f(i+1, j-1)+1
5. åˆ™å¯¹äºè¿™ä¸¤ç§æƒ…å†µæˆ‘ä»¬åˆ†åˆ«éœ€è¦é‡æ–°è®¡ç®—s(i, j-1)å’Œs(i+1, j)ã€‚

æœ€ç»ˆå¯ä»¥å¾—å‡º f(i,j) = max{f(i+1, j-1)&&str[i]==str[j], f(i,j-1), f(i+1,j)}ï¼Œå…¶ä¸­å½“str[i]==str[j]æ—¶ï¼Œf(i+1, j-1)+2ä¸€å®šæ˜¯æœ€å¤§çš„

## æ±‚è§£
ç”¨dp[i][j]ä»£è¡¨f(i,j)ï¼Œç”±äºdp[i][j]ä¾èµ–dp[i+1][j-1]å’Œdp[i+1][j]ï¼Œæˆ‘ä»¬iä»å³å¼€å§‹éå†ï¼Œjä»å·¦å¼€å§‹éå†ï¼Œå®ç°ä»£ç å¦‚ä¸‹ï¼š
```golang
//çœç•¥maxå‡½æ•°å®šä¹‰
func longestPalindromeSubseq(s string) int {
	n := len(s)
	dp := make([][]int, n)
	for i := 0; i < n; i++ {
		dp[i] = make([]int, n)
		dp[i][i] = 1
	}
	for i := n - 2; i >= 0; i-- {
		for j := i + 1; j < n; j++ {
			if s[i] == s[j] {
				dp[i][j] = dp[i+1][j-1] + 2
			} else {
				dp[i][j] = max(dp[i+1][j], dp[i][j-1])
			}
		}
	}
	return dp[0][n-1]
}
```
å…¶ä¸­dp[i][i]=1ï¼Œä»£è¡¨åªæœ‰str[i]ä¸€ä¸ªå­—ç¬¦ã€‚

## ä¼˜åŒ–
è§‚å¯Ÿdp[i][j]çš„æ±‚è§£å¯ä»¥çœ‹å‡ºï¼Œä¾èµ–å½“å‰è¡Œj-1çš„çŠ¶æ€ï¼ŒåŒæ—¶ä¾èµ–ä¸‹ä¸€è¡Œç›¸åŒä½ç½®jå’Œå·¦è¾¹j-1çš„çŠ¶æ€ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦ä¸¤è¡Œæ•°ç»„æ¥å­˜å‚¨ä¸‹ä¸€è¡Œå’Œå½“å‰è¡Œçš„çŠ¶æ€ã€‚ä¼˜åŒ–ä»£ç å¦‚ä¸‹:
```golang
// çœç•¥maxå‡½æ•°å®šä¹‰
func longestPalindromeSubseq(s string) int {
	n := len(s)
	if n == 1 {
		return 1
	}
	dp := make([]int, n)
	nextlineDp := make([]int, n)
	nextlineDp[n-1] = 1
	for i := n - 2; i >= 0; i-- {
		dp[i] = 1
		for j := i + 1; j < n; j++ {
			if s[i] == s[j] {
				dp[j] = nextlineDp[j-1] + 2
			} else {
				dp[j] = max(nextlineDp[j], dp[j-1])
			}
		}
		for j := i; j < n; j++ { // æ›´æ–°ä¸‹ä¸€è¡Œçš„çŠ¶æ€
			nextlineDp[j] = dp[j]
		}
	}
	return dp[n-1]
}
```
æœ€è¿‘å‘ç°é€šè¿‡è§‚å¯Ÿä»£ç æ¥ä¼˜åŒ–ç©ºé—´å¤æ‚åº¦å¾€å¾€æ›´ç®€å•ï¼Œå› ä¸ºi+1,i-1è¿™ç§è¡¨ç¤ºæ›´ç›´è§‚ï¼Œä¸è¿‡è¿˜æ˜¯æƒ³ä»åŸç†çš„è§’åº¦æ¥åˆ†æä¸€ä¸‹ä¼˜åŒ–çš„åŸç†ï¼Œä»¥è¿™é“é¢˜ä¸ºä¾‹ï¼š
```golang
// f(i,j) = max{f(i+1, j-1)&&str[i]==str[j], f(i,j-1), f(i+1,j)}
if s[i] == s[j] {
	dp[i][j] = dp[i+1][j-1] + 2
} else {
	dp[i][j] = max(dp[i+1][j], dp[i][j-1])
}
```
dpæ˜¯ä¸€ä¸ªçŸ©é˜µï¼Œå½“æ±‚dp[i][j]æ—¶ï¼Œå¾ˆå®¹æ˜“çŸ¥é“åªä¾èµ–i+1è¡Œçš„çŠ¶æ€ï¼Œæ‰€ä»¥ç¬¬ä¸€æ­¥spaceä»O(n^2)åˆ°O(2n)ï¼Œå†å…¶æ¬¡
1. ç¬¬iè¡Œä¾èµ–å½“å‰è¡Œå·¦è¾¹çš„æ•°æ®
2. ç¬¬iè¡Œä¾èµ–i+1å·¦è¾¹çš„æ•°æ®å’Œå½“å‰ä½ç½®çš„æ•°æ®

ç”±1æˆ‘ä»¬çŸ¥é“å½“å‰è¡Œæ¯”å¦‚ä»å·¦å¾€å³å¼€å§‹æ±‚è§£ï¼Œå†åŠ ä¸Š2ï¼Œè¿˜ä¾èµ–i+1å·¦è¾¹çš„æ•°æ®ï¼Œåˆ™ä¸èƒ½ç”¨å½“å‰è¡Œæ¥ä¿å­˜i+1è¡Œçš„å·¦è¾¹çš„çŠ¶æ€ï¼Œå› ä¸ºä¼šè¢«å½“å‰è¡Œè¦†ç›–æ‰ï¼Œæ‰€ä»¥è¿™é“é¢˜æœ€å°‘éœ€è¦ä¸¤ä¸ªä¸€ç»´æ•°ç»„æ¥å­˜å‚¨æ±‚è§£çš„å­çŠ¶æ€ã€‚

å¯¹äºä¸€äº›çŠ¶æ€è½¬ç§»æ–¹ç¨‹æ¯”å¦‚`dp[i][j] = max(dp[i-1][j-1], dp[i-1][j])`å’Œ`dp[i][j] = max(dp[i][j-1], dp[i-1][j])`è¿™ç§ï¼Œæˆ‘ä»¬åªå•ä¸ªä¾èµ–å½“å‰è¡Œæˆ–è€…ä¸Šä¸€è¡Œå·¦è¾¹çš„çŠ¶æ€ï¼Œå°±å¯ä»¥ç”¨å½“å‰è¡Œæ¥å­˜å‚¨ä¸Šä¸€è¡Œå·¦è¾¹çš„çŠ¶æ€ï¼Œå³`dp[j]=max(dp[j-1],dp[j])`å½“å‰è¡Œä»å³è¾¹å¼€å§‹éå†å’Œ`dp[j]=max(dp[j-1],dp[j])`å½“å‰è¡Œä»å·¦è¾¹å¼€å§‹éå†ã€‚

æ€»ç»“ä¸€ä¸‹å°±æ˜¯å½“ä¸ä¼šä¾èµ–ä¸¤è¡Œçš„åŒä¸€ä½ç½®çš„çŠ¶æ€æ—¶ï¼Œspaceå¯ä»¥ä¼˜åŒ–åˆ°O(n)ä¸€ä¸ªä¸€ç»´æ•°ç»„ã€‚

# [Out of Boundary Paths](Out of Boundary Paths)
```
ç»™å®šä¸€ä¸ªm*nçš„è¡¨æ ¼å’Œä¸€ä¸ªè¶³çƒï¼Œè¶³çƒä¸€å¼€å§‹æ”¾åœ¨è¡¨æ ¼çš„ï¼ˆiï¼Œjï¼‰åæ ‡å¤„ï¼Œè¶³çƒå¯ä»¥å¾€ä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘ç§»åŠ¨ï¼Œç»™å®šæ€»çš„å¯ä»¥èµ°çš„æ­¥æ•°Nï¼Œé—®è¶³çƒæœ‰å¤šå°‘ç§èµ°å‡ºè¡¨æ ¼è¾¹ç•Œçš„æ–¹å¼ï¼Ÿæœ€åçš„ç»“æœå–æ¨¡1000000007ã€‚

å…¶ä¸­ 1<=m,n <=50, 0<N<50

æ¯”å¦‚ï¼šè¾“å…¥m = 2, n = 2, N = 2, i = 0, j = 0
è¾“å‡ºï¼š6
```

## DFS
å¾ˆç®€å•çš„ä¸€é“é¢˜ï¼ŒDFSå³å¯ï¼Œæ ¹æ®å‡½æ•°åŸå‹å°±èƒ½è¿…é€Ÿçš„å†™å‡ºé€’å½’ä»£ç ï¼Œå®ç°å¦‚ä¸‹ï¼š
```golang
func findPaths(m int, n int, N int, i int, j int) int {
	if i < 0 || j < 0 || i >= m || j >= n {
		return 1
	}
	if N <= 0 {
		return 0
	}
	return findPaths(m, n, N-1, i-1, j) + findPaths(m, n, N-1, i+1, j) + findPaths(m, n, N-1, i, j-1) + findPaths(m, n, N-1, i, j+1)
}
```
åˆ†åˆ«å¾€å››ä¸ªæ–¹å‘æ·±åº¦ä¼˜å…ˆæœç´¢æ‰€æœ‰å¯èƒ½çš„è·¯å¾„ï¼š
1. iå’Œjè¶…å‡ºè¾¹ç•Œæ—¶Nåˆ°0çš„æ—¶å€™è¡¨ç¤ºå½“å‰è¿™æ¡è·¯å¾„å¯ä»¥èµ°å‡ºè¡¨æ ¼è¾¹ç•Œï¼Œè¿”å›1ï¼›
2. å¦åˆ™N-=0æ—¶è¡¨ç¤ºæ²¡æœ‰å¯ä»¥æ¶ˆè€—çš„æ­¥æ•°äº†ï¼Œè¿”å›0ï¼›
3. N != 0æ—¶ï¼Œç»§ç»­æœç´¢ã€‚

å½“ç„¶ï¼Œä¸å‡ºæ„å¤–è¶…æ—¶äº†ã€‚ã€‚ã€‚ã€‚ğŸ˜‚

ä»”ç»†åˆ†æä¸€ä¸‹ï¼š
1. æˆ‘ä»¬ä»(i,j)å‡ºå‘ï¼Œæœç´¢å‘ä¸Š(i-1,j)ã€å‘å·¦(i, j-1)ã€å‘ä¸‹æœç´¢(i+1,j)å’Œå‘å³æœç´¢(i,j+1)
2. å‘ä¸Š(i-1,j)å’Œå‘å·¦(i, j-1)æ—¶ï¼š(i-1,j)ä¼šå‘å·¦æœç´¢(i-1,j-1)ï¼Œ(i,j-1)ä¼šå‘ä¸Šæœç´¢(i-1,j-1)ï¼Œè¿™é‡Œä¼šäº§ç”Ÿé‡å¤çš„æœç´¢(i-1,j-1)
3. ç»¼ä¸Šæ‰€è¿°æœç´¢è¿‡ç¨‹ä¸­ä¼šæœ‰å¾ˆå¤šçš„é‡å¤æœç´¢

## DFS With Memo
æ ¹æ®ä¸Šé¢DFSçš„åˆ†æï¼Œæœç´¢è¿‡ç¨‹ä¸­ä¼šæœ‰å¾ˆå¤šé‡å¤æœç´¢ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±è¦ä¼˜åŒ–è¿™äº›ä¸å¿…è¦çš„é‡å¤æœç´¢ï¼Œå‡å¦‚ä¹‹å‰æœç´¢è¿‡è¿™æ¡è·¯å¾„äº†ï¼ŒæŠŠç»“æœå­˜å‚¨èµ·æ¥ï¼Œä¸‹ä¸€æ¬¡æœ‰å…¶å®ƒæœç´¢éœ€è¦è¿™ä¸ªè·¯å¾„çš„æœç´¢ç»“æœæ—¶ï¼Œç›´æ¥å–å­˜å‚¨å³å¯ï¼Œè¿™æ ·å°±é¿å…äº†é‡å¤çš„æœç´¢ã€‚

å½“ç„¶ï¼Œ*ä»(i,j)ç‚¹æœç´¢ï¼Œå‰©ä½™ä¸åŒçš„æ­¥æ•°ï¼Œç»“æœæ˜¯ä¸ä¸€æ ·çš„*ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦ä¸€ä¸ªä¸‰ç»´æ•°ç»„æ¥å­˜å‚¨è¿™ä¸ªæœç´¢ç»“æœï¼š**å³ç”¨dp[N][i][j]è¡¨ç¤ºï¼Œä»(i,j)å‡ºå‘ï¼Œæœ‰Næ­¥å¯ç”¨ï¼Œèµ°å‡ºè¾¹ç•Œçš„æ–¹å¼ä¸ªæ•°ã€‚**

åŒæ—¶ï¼Œéœ€è¦çŸ¥é“å½“å‰dp[N][i][j]æ˜¯å¦æ˜¯æœç´¢è¿‡çš„ï¼Œè¿™ä¸€ç‚¹æˆ‘ä»¬å¯ä»¥åœ¨åˆå§‹åŒ–æ•°ç»„çš„æ—¶å€™æŠŠå€¼åˆå§‹åŒ–ä¸º-1ï¼Œç”±äºdp[N][i][j]æœ€å°æ˜¯0ï¼Œå½“dp[N][i][j]çš„å€¼å¤§äºç­‰äº0å³è¡¨ç¤ºdp[N][i][j]å·²ç»æœç´¢è¿‡ã€‚

å®ç°ä»£ç å¦‚ä¸‹ï¼š

```golang
func mod1097(num int) int {
	mod := 1000000007
	return num % mod
}
func findPathsWithDP(m int, n int, N int, i int, j int, dp [][][]int) (int, [][][]int) {
	if i < 0 || j < 0 || i >= m || j >= n {
		return 1, dp
	}
	if N == 0 {
		dp[N][i][j] = 0
		return 0, dp
	}
	if dp[N][i][j] != -1 {
		return dp[N][i][j], dp
	}
	t1, dp := findPathsWithDP(m, n, N-1, i-1, j, dp)
	t2, dp := findPathsWithDP(m, n, N-1, i+1, j, dp)
	t3, dp := findPathsWithDP(m, n, N-1, i, j-1, dp)
	t4, dp := findPathsWithDP(m, n, N-1, i, j+1, dp)
	t := mod1097(t1) + mod1097(t2) + mod1097(t3) + mod1097(t4)
	dp[N][i][j] = mod1097(t)
	return dp[N][i][j], dp
}
func findPaths(m int, n int, N int, i int, j int) int {
	if N == 0 {
		return 0
	}
	dp := make([][][]int, N+1)
	for t := 0; t <= N; t++ {
		dp[t] = make([][]int, m)
		for i := 0; i < m; i++ {
			dp[t][i] = make([]int, n)
			for j := 0; j < n; j++ {
				dp[t][i][j] = -1
			}
		}
	}
	t, _ := findPathsWithDP(m, n, N, i, j, dp)
	return mod1097(t)
}
```

* è¿™é‡Œåšçš„æ—¶å€™å¡äº†å¾ˆä¹…ï¼Œä¸€ç›´ä¸çŸ¥é“åº”è¯¥æ€ä¹ˆæ ·ä¿è¯è®¡ç®—è¿‡ç¨‹ç»“æœä¸æº¢å‡ºï¼Œåæ¥çœ‹é¢˜è§£æ‰çŸ¥é“æ¨¡è¿ç®—æ˜¯æ»¡è¶³åˆ†é…å¾‹ï¼Œæœç´¢è¿‡ç¨‹ä¸­ç”¨æ¨¡çš„ç»“æœå½“åšdpå€¼å®Œå…¨æ²¡æœ‰é—®é¢˜ï¼š`a%m + b%m = (x*m + c)%m + (y*m + d)%m = (x+y)*m + (c + d) = ((x+y)*m + (c+d))%m = (a+b)%m`
* åšçš„æ—¶å€™ä¸€ç›´æŠŠè¿™ä¸ªè§£æ³•å«åšDFS with DPï¼Œå› ä¸ºæˆ‘ä»¬æ˜¯ç”¨ä¸€ä¸ªæ•°ç»„å»å­˜å‚¨æ±‚è§£çš„å­é—®é¢˜ï¼Œåªä¸è¿‡æ±‚è§£çš„è¿‡ç¨‹æ˜¯DFSï¼Œè€Œä¸æ˜¯å¸¸è§çš„éå†

## DP
è§‚å¯Ÿä¸Šé¢çš„DFSè§£æ³•ï¼Œå¯ä»¥çœ‹åˆ°å…¶å®å¯¹äºNæ¥è¯´ï¼Œdp[N][i][j]ä¾èµ–dp[n-1]çš„çŠ¶æ€ï¼Œæˆ‘ä»¬å¯ä»¥é¡ºåºéå†Nï¼Œç”¨éé€’å½’çš„è§£æ³•æ±‚è§£ã€‚å®ç°ä»£ç å¦‚ä¸‹ï¼š

```golang
func findPaths(m int, n int, N int, i int, j int) int {
	if N == 0 {
		return 0
	}
	dp := make([][][]int, N+1)
	for t := 0; t <= N; t++ {
		dp[t] = make([][]int, m)
		for i := 0; i < m; i++ {
			dp[t][i] = make([]int, n)
		}
	}
	for t := 1; t <= N; t++ {
		for i := 0; i < m; i++ {
			for j := 0; j < n; j++ {
				k := 0
				if i == 0 {
					k += 1
				} else {
					k += dp[t-1][i-1][j]
				}
				if i == m-1 {
					k += 1
				} else {
					k += dp[t-1][i+1][j]
				}
				if j == 0 {
					k += 1
				} else {
					k += dp[t-1][i][j-1]
				}
				if j == n-1 {
					k += 1
				} else {
					k += dp[t-1][i][j+1]
				}
				k = mod1097(k)
				dp[t][i][j] = k
			}
		}
	}
	return dp[N][i][j]
}
```

å†ä¼˜åŒ–ä¸€ä¸‹ï¼Œå…¶å®åªéœ€è¦ä¸¤ä¸ªäºŒç»´æ•°ç»„å³å¯ï¼Œå®ç°å¦‚ä¸‹ï¼š
```golang
func findPaths(m int, n int, N int, i int, j int) int {
	if N == 0 {
		return 0
	}
	dp := make([][]int, m)
	preDp := make([][]int, m)
	for i := 0; i < m; i++ {
		dp[i] = make([]int, n)
		preDp[i] = make([]int, n)
	}
	for t := 1; t <= N; t++ {
		for i := 0; i < m; i++ {
			for j := 0; j < n; j++ {
				k := 0
				if i == 0 {
					k += 1
				} else {
					k += preDp[i-1][j]
				}
				if i == m-1 {
					k += 1
				} else {
					k += preDp[i+1][j]
				}
				if j == 0 {
					k += 1
				} else {
					k += preDp[i][j-1]
				}
				if j == n-1 {
					k += 1
				} else {
					k += preDp[i][j+1]
				}
				k = mod1097(k)
				dp[i][j] = k
			}
		}
		for i := 0; i < m; i++ {
			for j := 0; j < n; j++ {
				preDp[i][j] = dp[i][j]
			}
		}
	}
	return dp[i][j]
}
```

# EOF
å†™çš„å¤´æ™•äº†ï¼Œæœ€è¿‘æ€»æ˜¯åœ¨æŒ‘é€‰ç‚¹èµé«˜çš„mediumé¢˜åšï¼Œåˆé™·å…¥äº†â€œèˆ’é€‚åŒºâ€œâ€¦â€¦ä¸‹å‘¨åŠ æ²¹ï¼Œç»§ç»­è·³å‡ºèˆ’é€‚åŒºï¼