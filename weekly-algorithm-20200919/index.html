<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="[Weekly Algorithm]20200919: Dynamic programming III"><meta name="keywords" content="Combination Sum IV,Arithmetic Slices,Partition Equal Subset Sum"><meta name="author" content="furthergo"><meta name="copyright" content="furthergo"><title>[Weekly Algorithm]20200919: Dynamic programming III | furthergo</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.8.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.8.2"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.8.2"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><meta name="google-site-verification" content="oQkdLBTArbDoNq8FA6P9TiTYGdELfAVbSvkRTq9Heps"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '4.2.1'
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0x00-总结"><span class="toc-number">1.</span> <span class="toc-text">0x00 总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x01-Combination-Sum-IV"><span class="toc-number">2.</span> <span class="toc-text">0x01 Combination Sum IV</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#分析"><span class="toc-number">2.1.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#求解"><span class="toc-number">2.2.</span> <span class="toc-text">求解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x02-Arithmetic-Slices"><span class="toc-number">3.</span> <span class="toc-text">0x02 Arithmetic Slices</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#分析-1"><span class="toc-number">3.1.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#求解-1"><span class="toc-number">3.2.</span> <span class="toc-text">求解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DP解法"><span class="toc-number">3.3.</span> <span class="toc-text">DP解法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x03-Partition-Equal-Subset-Sum"><span class="toc-number">4.</span> <span class="toc-text">0x03 Partition Equal Subset Sum</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#分析-2"><span class="toc-number">4.1.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#求解-2"><span class="toc-number">4.2.</span> <span class="toc-text">求解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#EOF"><span class="toc-number">5.</span> <span class="toc-text">EOF</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.JPG"></div><div class="author-info__name text-center">furthergo</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/furthergo" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">12</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">8</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">3</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/1.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">furthergo</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/sitemap.xml || sitemap">Sitemap</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">[Weekly Algorithm]20200919: Dynamic programming III</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-09-19</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Weekly-Algorithm/">Weekly Algorithm</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="0x00-总结"><a href="#0x00-总结" class="headerlink" title="0x00 总结"></a>0x00 总结</h1><ul>
<li>本周一共刷了三道题，medium</li>
<li>两道常规dp题，一道背包问题，会重点介绍一下这道背包问题</li>
</ul>
<h1 id="0x01-Combination-Sum-IV"><a href="#0x01-Combination-Sum-IV" class="headerlink" title="0x01 Combination Sum IV"></a>0x01 <a href="https://leetcode.com/problems/combination-sum-iv/" target="_blank" rel="noopener">Combination Sum IV</a></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个无重复数字的正整数数组和一个target，尝试从数组中取和为target的数字，问共有多少种数字的组合？</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">比如nums &#x3D; [1, 2, 3]，target &#x3D; 4</span><br><span class="line">所有可能的组合有7种:</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br><span class="line"></span><br><span class="line">注意不同数字顺序算不同的组合，比如(1, 1, 2)和(1, 2, 1)是两种</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>根据上面的例子分析，和为4的所有的数字的组合，等于</p>
<ol>
<li>和为3的所有的数字组合里添加1（假如数组里包含1），加上</li>
<li>和为2的所有的数字组合里添加2（假如数组里包含2），加上</li>
<li>和为1的所有的数字组合里添加3（假如数组里包含3），加上</li>
<li>和为0的所有的数字组合里添加4（假如数组里包含4）.</li>
</ol>
<p>假设f(n)为和为n的所有数字的组合个数，c(i)代表数组nums里包含数字i，则</p>
<center>
f(n) = f(n-1)&&c(1) + f(n-2)&&c(2) + ... + f(0)&&c(n)

<p>从0到n-1</p>
</center>

<p>这里的f(n)就是求解过程中的子问题，我们只需要从f(0)计算到f(target)即可，注意这里f(0)是边界case，由于都是正整数，f(0)就代表一个数组中的数也不选，有一种可能，即f(0)=1。</p>
<p>c(i)表示nums中是否存在i，如果按照上述的方法，我们需要从f(0)计算到f(target)，同时每一步都需要计算c(i)，时间复杂度太高了，可以换一个角度：<strong>从nums里取数字</strong>，然后用target减去这个数字。还是以上面的例子分析，和为4的所有的数字的组合，等于</p>
<ol>
<li>和为4-nums[0]=3的所有的数字组合，加上</li>
<li>和为4-nums[1]=2的所有的数字组合，加上</li>
<li>和为4-nums[2]=1的所有的数字组合.</li>
</ol>
<p>即</p>
<center>
f(n) = f(n-nums[0]) + f(n-nums[1])  + ... + f(n-nums[len(nums)-1]) 

<p>注意这里需要nums[i]小于等于n</p>
</center>

<p>这里我们可以先对nums排一下序，遇到nums[i]&gt;n就可以退出遍历了</p>
<h2 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h2><p>初始化dp[target+1]存储f(n)，其中<code>f(i) = dp[i], dp[0] = f(0) = 1</code>，实现代码如下:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum4</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, target+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i&lt;=target; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">            <span class="keyword">if</span> v &lt;= i &#123;</span><br><span class="line">                dp[i] += dp[i-v]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="0x02-Arithmetic-Slices"><a href="#0x02-Arithmetic-Slices" class="headerlink" title="0x02 Arithmetic Slices"></a>0x02 <a href="https://leetcode.com/problems/arithmetic-slices/" target="_blank" rel="noopener">Arithmetic Slices</a></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">首先：</span><br><span class="line">定义Arithmetic Sequence代表序列中任意两个相邻的元素的差值都相同。</span><br><span class="line"></span><br><span class="line">给定一个数组A，求这个数组有多少个切片是Arithmetic的，注意这里切片是Arithmetic的前提是切片的长度大于等于3。</span><br><span class="line"></span><br><span class="line">比如</span><br><span class="line">A &#x3D; [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">返回为3, 代表A有三个Arithmetic的切片: [1, 2, 3], [2, 3, 4] 和 [1, 2, 3, 4].</span><br></pre></td></tr></table></figure>

<h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>首先最暴力的解法，求出A的所有的可能的切片，然后判断每个切片是不是Arithmetic的，A的长度为n，则共有 n-1 + n-2 + … + 1 = n(n-1)/2 个长度至少为2的切片，还需要判断每个切片是否是Arithmetic，时间复杂度是O(n^3)。下面我们从暴力解法出发，尝试优化一下时间复杂度：</p>
<ol>
<li>所有的切片可以分类为从index为0开始的切片，从index为1开始的切片，…… ， 从index为n-2开始的切片；</li>
<li>假如从index为i开始，长度为l的切片是Arithmetic的，那么<ul>
<li>从index为i开始，长度为3、… 、l的切片都是Arithmetic的，一共有l-2个；</li>
<li>从index为i+1开始，长度为3、… 、l-1的切片都是Arithmetic的，一共有l-3个；</li>
<li>从index为i+2开始，长度为3、… 、l-2的切片都是Arithmetic的，一共有l-4个；</li>
<li>…</li>
<li>从index为i+l-3开始，长度为3的切片都是Arithmetic的，一共有1个；</li>
<li>即一共有(l-2) + (l-3) + … + 1 = (l-1)*(l-2)/2个</li>
</ul>
</li>
<li>在从index为i开始的切片里，假如长度为l的切片不是Arithmetic的，那么长度为l+1的切片一定也不是Arithmetic的，这里就没有再往下计算的必要了；</li>
</ol>
<p>那么综合上面三条分析，当我们从index为i开始，找到满足Arithmetic的长度最长的切片，假设最长为l，则<strong>从index为i，i+1，… ，i+l-2开始的所有满足Arithmetic的切片都已经被找到了</strong>，接下来我们只需要从index为i+l-1开始，重新找满足Arithmetic的长度最长的切片即可，即求解步骤为</p>
<ol>
<li>index初始化0</li>
<li>从index，找到index=0开始满足Arithmetic的最长切片，假设长度为l</li>
<li>根据上述2更新res += (l-1)*(l-2)/2</li>
<li>index更新为i+l-2，重复步骤234</li>
<li>因为Arithmetic的切片长度至少为3，则index最大为n-3</li>
</ol>
<h2 id="求解-1"><a href="#求解-1" class="headerlink" title="求解"></a>求解</h2><p>实现代码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(A []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    n := <span class="built_in">len</span>(A)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i&lt;n<span class="number">-2</span>; &#123;</span><br><span class="line">        <span class="keyword">if</span> A[i+<span class="number">1</span>] - A[i] == A[i+<span class="number">2</span>] - A[i+<span class="number">1</span>] &#123;</span><br><span class="line">            j := i+<span class="number">2</span> <span class="comment">// j代表当前slice的最后一个数的index</span></span><br><span class="line">            <span class="keyword">for</span> ; j&lt;n<span class="number">-1</span>; j++ &#123; <span class="comment">// j最大为n-2</span></span><br><span class="line">                <span class="keyword">if</span> A[j+<span class="number">1</span>]-A[j] != A[j] - A[j<span class="number">-1</span>] &#123; <span class="comment">// 尝试扩充slice的长度</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            l := j - i + <span class="number">1</span> <span class="comment">// 最长arithmetic的切片长度</span></span><br><span class="line">            res += (l<span class="number">-1</span>)*(l<span class="number">-2</span>)/<span class="number">2</span></span><br><span class="line">            i = j - <span class="number">1</span> </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里虽然是两层循环，但是第一层循环的步长是由第二层遍历到的位置更新的，所以时间复杂度是O(n)，空间复杂度是O(1)。</p>
<h2 id="DP解法"><a href="#DP解法" class="headerlink" title="DP解法"></a>DP解法</h2><p>上面的解法其实是暴力解法的优化版，这道题是DP分类里的，所以我们再来从DP的角度分析和求解。</p>
<ul>
<li>用f(i)代表以A[i]结尾的所有的满足Arithmetic的切片的个数</li>
<li>求解f(i)时：<ol>
<li>假如A[i]-A[i-1] == A[i-1]-A[i-2]，即(A[i-2], A[i-1], A[i])满足Arithmetic</li>
<li>则对于所有的f(i-1)的切片，A[i]-A[i-1] == A[i-1]-A[i-2] == A[i-2]-A[i-3] == …</li>
<li>即假如1满足，那么以A[i-1]结尾的所有满足Arithmetic的切片之后，添加一个A[i]，同样是Arithmetic的</li>
<li>同时有一个新的满足Arithmetic的切片(A[i-2], A[i-1], A[i])产生</li>
</ol>
</li>
<li>即f(i) = f(i-1)+1</li>
</ul>
<p>我们用dp[i]代表f(i)，则状态转移方程为：</p>
<center> dp[i] = dp[i-1] + 1 

<p>当A[i]-A[i-1] == A[i-1]-A[i-2]，否则</p>
<p>dp[i] = 0</p>
</center>

<p>同时观察到dp[i]只依赖dp[i-1]，则我们只需要一个变量来存储前一个状态即可，实现代码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(A []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    n := <span class="built_in">len</span>(A)</span><br><span class="line">    dp := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i&lt;n;i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> A[i] - A[i<span class="number">-1</span>] == A[i<span class="number">-1</span>] - A[i<span class="number">-2</span>] &#123;</span><br><span class="line">            dp += <span class="number">1</span></span><br><span class="line">            res += dp</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度是O(n)，空间复杂度是O(1)</p>
<h1 id="0x03-Partition-Equal-Subset-Sum"><a href="#0x03-Partition-Equal-Subset-Sum" class="headerlink" title="0x03 Partition Equal Subset Sum"></a>0x03 <a href="https://leetcode.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">Partition Equal Subset Sum</a></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给定一个只包含正整数的非空数组，判断数组是否能被划分成两个和相等的子集。</span><br><span class="line"></span><br><span class="line">比如</span><br><span class="line">输入: [1, 5, 11, 5]</span><br><span class="line">输出: true</span><br><span class="line">数组可以被划分为 [1, 5, 5] and [11].</span><br></pre></td></tr></table></figure>

<h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>被划分成两个和相等的子集，首先要满足：</p>
<ul>
<li>数组个数大于1</li>
<li>数组元素的和是偶数</li>
</ul>
<p>在满足上面两个条件之后，我们可以先求出数组元素和的一半half，接下来问题就转换成，从数组中找子集，满足子集元素的和等于half。</p>
<p>这是一个典型的背包问题，找子集满足子集元素的和等于half，那么对于数组中的每个元素，我们可以把它放到最后的子集里，或者不放到最后的子集里，这里子集看成一个背包，就是一个0-1背包问题。暴力的解法就是DFS，对于每个元素尝试放或者不放到子集里，用暴力的方法写了一下，结果超时了：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> target == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	n := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> || target &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dfs(nums[:n<span class="number">-1</span>], target) || dfs(nums[:n<span class="number">-1</span>], target-nums[n<span class="number">-1</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canPartition</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(nums)</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		sum += nums[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> sum%<span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	half := sum / <span class="number">2</span></span><br><span class="line">	<span class="keyword">return</span> dfs(nums, half)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然直接DFS不行，还是从DP的角度来分析：求是否有满足和为target的子集，我们只需要从求和有为1的子集开始，和为2，… ，从这些子问题求最终是否存在和为target的子集。</p>
<p>假如我们知道了前i-1个数的子集能组成的和的结果，那么对于前i个数来说，求能否有一个子集的和为j时，有两种可能：</p>
<ol>
<li>元素i不在这个子集里，即前i-1个数里有一个和为j的子集</li>
<li>元素i在这个子集里，即前i-1个数里有一个和为j-nums[i]的子集，这里需要nums[i]小于等于j</li>
<li>12都不满足，则前i个数中不存在和为j的子集</li>
</ol>
<p>我们用dp[i][j]代表0-i的数里有和为j的子集，则可以得出：</p>
<center>dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i]]
</center>

<p>我们可以用一个n行，target+1列的矩阵来存储计算结果，同时我们观察上述状态转移方程，dp[i][j]只依赖前一行的左边的计算结果，则可以优化dp矩阵为单行，这个优化方式之前的文章里写过，不再赘述。</p>
<p>因为这里依赖dp[i-1][j-nums[i]]，所以最多只能优化到一行，其次由于依赖左边的计算结果，我们需要倒序遍历更新dp数组，防止当前行的计算结果覆盖前一行的结果，影响当前行的计算</p>
<h2 id="求解-2"><a href="#求解-2" class="headerlink" title="求解"></a>求解</h2><p>实现代码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumToTarget</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(nums)</span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="keyword">bool</span>, target+<span class="number">1</span>)</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := target; j&gt;=<span class="number">1</span>; j-- &#123; <span class="comment">// 因为dp[j]依赖前一行的j之前的元素的状态，反向遍历防止前一行元素的状态被覆盖</span></span><br><span class="line">			<span class="comment">// dp[j]代表0-i的元素里，有和为j的子集</span></span><br><span class="line">			<span class="comment">// dp[j] = dp[j] || dp[j-nums[i]]</span></span><br><span class="line">			<span class="keyword">if</span> nums[i] &lt;= j &#123;</span><br><span class="line">				dp[j] = dp[j] || dp[j-nums[i]]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span> <span class="comment">// j是递减的，之后的元素都比nums[i]小</span></span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[target]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canPartition</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(nums)</span><br><span class="line">	<span class="keyword">if</span> n &lt;= <span class="number">1</span>&#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line"></span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">		sum += nums[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> sum % <span class="number">2</span> != <span class="number">0</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line"></span><br><span class="line">	half := sum / <span class="number">2</span></span><br><span class="line">	<span class="keyword">return</span> sumToTarget(nums, half)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为O(n*target)，空间复杂度为O(target)。</p>
<h1 id="EOF"><a href="#EOF" class="headerlink" title="EOF"></a>EOF</h1><ul>
<li>背包问题，这个需要后面碰到后再总结</li>
<li>心血来潮的自律不如日积月累的好习惯，养成好的习惯很重要</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">furthergo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://furthergo.github.io/weekly-algorithm-20200919/">https://furthergo.github.io/weekly-algorithm-20200919/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/algorithm/">algorithm</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/weekly-algorithm-20200926/"><i class="fa fa-chevron-left">  </i><span>[Weekly Algorithm]20200926: Dynamic programming IV</span></a></div><div class="next-post pull-right"><a href="/weekly-algorithm-20200912/"><span>[Weekly Algorithm]20200912: Dynamic programming II</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '5172c31ed5ec5462891c',
  clientSecret: '2a57ab34b48ff0d860dd57f70547e3416ebe0d85',
  repo: 'furthergo.github.io',
  owner: 'furthergo',
  admin: 'furthergo',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(/img/1.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 By furthergo</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.8.2"></script><script src="/js/fancybox.js?version=1.8.2"></script><script src="/js/sidebar.js?version=1.8.2"></script><script src="/js/copy.js?version=1.8.2"></script><script src="/js/fireworks.js?version=1.8.2"></script><script src="/js/transition.js?version=1.8.2"></script><script src="/js/scroll.js?version=1.8.2"></script><script src="/js/head.js?version=1.8.2"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>