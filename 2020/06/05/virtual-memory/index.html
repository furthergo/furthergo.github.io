<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="虚拟内存"><meta name="keywords" content="OS,CSAPP"><meta name="author" content="furthergo"><meta name="copyright" content="furthergo"><title>虚拟内存 | furthergo</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><meta name="google-site-verification" content="oQkdLBTArbDoNq8FA6P9TiTYGdELfAVbSvkRTq9Heps"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0x00"><span class="toc-number">1.</span> <span class="toc-text">0x00</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#什么是虚拟内存"><span class="toc-number">2.</span> <span class="toc-text">什么是虚拟内存</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#为什么要有虚拟内存"><span class="toc-number">3.</span> <span class="toc-text">为什么要有虚拟内存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#主存是磁盘的缓存"><span class="toc-number">3.1.</span> <span class="toc-text">主存是磁盘的缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#页表"><span class="toc-number">3.1.1.</span> <span class="toc-text">页表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缺页"><span class="toc-number">3.1.2.</span> <span class="toc-text">缺页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#虚拟页为什么很大-4KB"><span class="toc-number">3.1.3.</span> <span class="toc-text">虚拟页为什么很大(4KB-?)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟内存作为内存管理的工具"><span class="toc-number">3.2.</span> <span class="toc-text">虚拟内存作为内存管理的工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简化链接"><span class="toc-number">3.2.1.</span> <span class="toc-text">简化链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简化共享"><span class="toc-number">3.2.2.</span> <span class="toc-text">简化共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简化加载"><span class="toc-number">3.2.3.</span> <span class="toc-text">简化加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简化内存分配"><span class="toc-number">3.2.4.</span> <span class="toc-text">简化内存分配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟内存作为内存保护的工具"><span class="toc-number">3.3.</span> <span class="toc-text">虚拟内存作为内存保护的工具</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#地址翻译"><span class="toc-number">4.</span> <span class="toc-text">地址翻译</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MMU"><span class="toc-number">4.1.</span> <span class="toc-text">MMU</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TLB"><span class="toc-number">4.2.</span> <span class="toc-text">TLB</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多级页表"><span class="toc-number">4.3.</span> <span class="toc-text">多级页表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-虚拟内存结构"><span class="toc-number">5.</span> <span class="toc-text">Linux 虚拟内存结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#mmap"><span class="toc-number">5.1.</span> <span class="toc-text">mmap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#共享对象和copy-on-write"><span class="toc-number">5.2.</span> <span class="toc-text">共享对象和copy on write</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.JPG"></div><div class="author-info__name text-center">furthergo</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/furthergo">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">4</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">4</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">1</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/bm1.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">furthergo</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">虚拟内存</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-06-05</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h1><p>首先看本文之前，先思考几个问题：</p>
<ol>
<li>在单CPU的电脑上，同一时间智能运行一个进程，CPU通过时间片的方式，模拟进程的同时运行。那多个运行的进程所使用的内存是如何管理的？是怎么保证多进程之间不会干扰到对方的内存区域</li>
<li>电脑在内存占用非常高的时候变得很卡，是为什么？</li>
<li>mmap为什么会更快<a id="more"></a>
<h1 id="什么是虚拟内存"><a href="#什么是虚拟内存" class="headerlink" title="什么是虚拟内存"></a>什么是虚拟内存</h1></li>
</ol>
<p>虚拟内存是指操作系统提供的一种管理存储资源的方式，屏蔽了cache、DRAM和硬盘的使用细节，为用户或者说是进程提供统一的、简洁的内存使用和管理方式，是计算机系统中非常重要的概念。</p>
<h1 id="为什么要有虚拟内存"><a href="#为什么要有虚拟内存" class="headerlink" title="为什么要有虚拟内存"></a>为什么要有虚拟内存</h1><ol>
<li>高效的使用主存</li>
<li>为进程提供一致的内存空间，简化内存管理</li>
<li>为进程提供独立的内存空间，保证安全性</li>
</ol>
<h2 id="主存是磁盘的缓存"><a href="#主存是磁盘的缓存" class="headerlink" title="主存是磁盘的缓存"></a>主存是磁盘的缓存</h2><p>虚拟内存把主存看做是硬盘存储的缓存，主存由于成本原因往往比硬盘小很多，虚拟内存通过页交换来保证当前使用的页面处于主存中。页面分为虚拟页和物理页，虚拟页是进程所看到的概念，物理页是实际存储的页面块。根据状态虚拟页可分为：未被分配的、已分配但未被缓存在主存中的和已分配并且缓存在主存中的。</p>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>根据虚拟页的状态，当进程需要访问一个虚拟页面的时候，它需要知道当前虚拟页是否可用以及对应物理页的位置，虚拟内存为每个进程提供了一个叫做页表(page table)的数据结构，它存储了当前进程的所有页面的实时信息，由页表条目(PTE: page table entry)组成，每个PTE包含一个有效未和n位地址位（对应物理地址空间的位数）：有效位为1时代表当前PTE页面在主存中，地址位对应其实际的物理地址；有效位未设置时代表当前页面未被分配（往往意味着当前访问的VA是不合法的）；当有效位为0时，代表物理页面未被缓存，此时会触发缺页异常。<br>页表是存在task_struct中的，而task_struct是内核控制的，存在每个进程的内核地址空间。</p>
<h3 id="缺页"><a href="#缺页" class="headerlink" title="缺页"></a>缺页</h3><p>当进程访问到一个有效位为0的PTE时，会发现物理页面不在主存中，n未地址位代表页面在磁盘上的位置。这时操作系统会触发缺页异常，内核的缺页处理程序捕捉到这个异常后，会根据一定的算法，从页表中选取一个牺牲页，写回（如果需要的话）这个页面的内容到磁盘中，并将实际之前尝试访问的页面根据其在磁盘上的位置，将其复制到牺牲页之前所在的物理地址处，并更新进程的页表，这个过程就叫做交换(swap)。处理完缺页异常后内核将进程执行到缺页异常之前的指令处，并将CPU交还给进程，进程此时再去访问之前的虚拟地址时，会发现PTE的有效位已经是1，可以根据物理地址取到对应的页面内容。</p>
<h3 id="虚拟页为什么很大-4KB"><a href="#虚拟页为什么很大-4KB" class="headerlink" title="虚拟页为什么很大(4KB-?)"></a>虚拟页为什么很大(4KB-?)</h3><p>DRAM比SRAM慢10倍左右，而磁盘比DRAM慢10000倍左右，同时访问扇区的第一个字节比访问整个扇区的内容要慢10 000倍。DRAM未命中的处罚和访问第一个字节的巨大开销，决定了虚拟页往往很大。那页面很大会不会导致操作系统频繁的出现缺页和swao导致CPU的运行效率变低呢？这时候那个贯穿计算机系统的概念又出现了：局部性。根据局部性原理，每个程序都倾向于在它的一个工作集(work set)中运行，在进程刚开始运行的时候，缺页率会比较高，那之后会逐渐降低。当然这要求我们的程序要有良好的局部性，良好的局部性能大大提高主存缓存的命中率，提高程序的运行速度。当工作集大于主存的大小的时候，虚拟系统会频繁的发生页面的换进换出，造成虚拟内存的抖动，降低程序的运行速度。</p>
<h2 id="虚拟内存作为内存管理的工具"><a href="#虚拟内存作为内存管理的工具" class="headerlink" title="虚拟内存作为内存管理的工具"></a>虚拟内存作为内存管理的工具</h2><h3 id="简化链接"><a href="#简化链接" class="headerlink" title="简化链接"></a>简化链接</h3><p>内存空间一致：栈、共享内存区、堆、data、text，一致的进程内存空间，统一了程序链接器的设计和实现，不用考虑实际的物理内存。</p>
<h3 id="简化共享"><a href="#简化共享" class="headerlink" title="简化共享"></a>简化共享</h3><p>通过映射到同一块物理页实现共享：除了进程的私有数据和代码，一些通用的数据和代码每个进程间都是一样的，比如系统库的函数，这种情况OS只需要把不同进程的页表中的虚拟地址映射到同一块物理地址，就可以实现内存的共享，同时对进程的使用是透明的。</p>
<h3 id="简化加载"><a href="#简化加载" class="headerlink" title="简化加载"></a>简化加载</h3><p>On-demand load：在加载可执行文件的时候，OS通过分配对应的无效状态虚拟页啦加载程序代码，当进程实际使用时，按需加载，触发page fault并加载磁盘中的页到主存中。</p>
<h3 id="简化内存分配"><a href="#简化内存分配" class="headerlink" title="简化内存分配"></a>简化内存分配</h3><p>提供连续的内存空间：OS可以给进程分配连续的虚拟页，通过页表，实现这些虚拟页映射的物理页可以在内存中的任意位置。</p>
<h2 id="虚拟内存作为内存保护的工具"><a href="#虚拟内存作为内存保护的工具" class="headerlink" title="虚拟内存作为内存保护的工具"></a>虚拟内存作为内存保护的工具</h2><p>为了保证进程正常的运行，不同区域的内存，存储不同内容的内存，不应该有相同的访问权限，OS通过给PTE添加一些控制位（内核权限、读、写）来实现访问控制，在进程尝试访问一个虚拟地址的时候，MMU首先会读到对应的PTE，如果当前访问不能PTE上的控制位或者不存在对应的PTE，CPU就会触发一个异常给异常处理程序，一般这个异常就叫做段错误segment fault。</p>
<h1 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h1><p>进程访问的都是虚拟地址，OS和CPU会把虚拟地址翻译成对应的物理地址，读取物理页的内容并返回给进程，虚拟地址到物理地址的映射就叫做地址翻译，MAP:VAS -&gt; PAS ∪ ∅</p>
<h2 id="MMU"><a href="#MMU" class="headerlink" title="MMU"></a>MMU</h2><p>MMU(Memory Management Unit)是CPU上的硬件，配合OS进行地址翻译，大致步骤如下：</p>
<ol>
<li>MMU接受一个VA</li>
<li>MMU生成VA对应的PTE地址，并从cache或者主存中请求拿到PTE</li>
<li>根据PTE构造对应的PA，并传给cache或者主存</li>
<li>cache或者主存从PA中读取数据并返回给CPU</li>
</ol>
<p>有几点需要注意的是：</p>
<ol>
<li>CPU有专门的寄存器存执页表的基地址，叫做页表基址寄存器（page table base register）</li>
<li>虚拟地址被分为两部分：VPN和VPO，虚拟页号和虚拟页偏移，VPO和PPO总是相同的，这样可以简化数据查找的过程</li>
<li>PTE和PA都会使用cache，即请求PTE的时候会先访问cache，拿到PA后还是会先访问cache。</li>
<li>访问cache时到底是使用VA还是PA，大部分OS选择PA<h2 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h2>Translation Lookaside Buffer，MMU请求PTE的时候，需要访问cache或者主存，这需要消耗CPU时间周期，因为地址翻译本身是一个很频繁且有局部性特点的工作，所以设计了TLB作为PTE的缓存，MMU会首先根据VA到TLB找对应的PTE，节省开销。TLB属于硬件的一部分。<h2 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h2>对于之前提到的页表，假如一个32位的虚拟地址空间，4KB的页大小，那么就要有2^20个PTE，每个PTE32 bit(20位代表页号，12位代表页内偏移)，总共页表的大小就是4MB，而根据局部性原理，大部分使用的PTE其实很集中，这就造成了内存的浪费，所以引入了多级页表。<br>多级页表把VA分为N个VPN部分，和一个VPO部分，VPN指向每级页表的PTE索引，1-n-1的页表PTE内容是下一级页表的基址，第n级的内容是该VA对应的PPN，使用PPN+VPO构建对应的PA。</li>
</ol>
<p>总结一下TLB和多级页表：使用多级页表来减少内存消耗，使用TLB来减少寻址开销。</p>
<h1 id="Linux-虚拟内存结构"><a href="#Linux-虚拟内存结构" class="headerlink" title="Linux 虚拟内存结构"></a>Linux 虚拟内存结构</h1><p>Linux的每个进程有单独的虚拟地址空间，把内存组织成段(vm_area)的集合，一段就是已经分配的内存的集合，内核不用记录那些不在内存中的虚拟页。从高地址到低地址依次是内核虚拟内存、用户栈、共享内存区域、堆、bss、data、text。这些段就是由vm_area_struct管理的，多个vm_area_struct组成一个链表，构成所有的段。</p>
<p>有几点需要注意的：</p>
<ol>
<li>内核部分的虚拟内存，可以大致分为两部分：① 进程间不同的部分，包括当前进程相关的的数据结构，比如页表、段集合等；② 进程间相同的部分，一是内核的代码和数据，二是物理内存，Linux把DRAM中连续的物理页映射到了同样连续的虚拟页中，更方便内核对物理地址的访问。</li>
<li>内核的缺页处理程序在收到某个VPA的异常时，会首先在vm_area_struct链表查找这个VPA，如果未找到就触发段错误；如果找到了但是违反访问保护，就触发保护异常；如果是合法的操作，就选择一个物理牺牲页，swap换进需要的物理页，并更新页表并返回，CPU会重新运行缺页的指令，正常运行。</li>
<li><a href="https://stackoverflow.com/questions/39689516/why-is-address-0x400000-chosen-as-a-start-of-text-segment-in-x86-64-abi" target="_blank" rel="noopener">为什么Linux进程的虚拟地址空间链接不是从0开始使用的，而是从比如0x40000开始使用的？</a> 原因之一是因为这样可以<a href="http://www.sco.com/developers/devspecs/abi386-4.pdf" target="_blank" rel="noopener">不需要实现对空指针访问的异常</a>。<h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h2>直接把磁盘对象映射到虚拟地址的方式，叫做内存映射（memory mapping）。这种可以映射的磁盘对象分为两种：</li>
<li>普通文件</li>
<li>匿名文件，即非磁盘上的普通文件，是内核创建出的一块全零的区域，使用场景主要是进程间通信，适用于父进程和子进程之间，父进程fork子进程之前，先mmap一块匿名文件，然后子进程因为继承父进程的资源，也拥有这块mmap的匿名文件，这样父子进程就可以利用这块匿名文件进行进程间通信。<br>两种情况都需要使用交换空间（swap space），只是匿名文件不存在磁盘到内存的数据传输，是将牺牲页换出（如果需要）到磁盘后直接写为全零。交换空间维护这当前进程能够分配的VP的总数。<h2 id="共享对象和copy-on-write"><a href="#共享对象和copy-on-write" class="headerlink" title="共享对象和copy on write"></a>共享对象和copy on write</h2>对于一个被映射到虚拟内存空间某个区域的对象，要么是共享对象，要么是私有对象。共享对象被映射到的区域的任何修改操作对所有进程都是可见的；而私有对象被映射到的区域的修改只在当前修改进程有感知，这种情况下，两个进程可以将私有对象映射到各自内存空间的不同区域，并且共享同一份物理内存副本，只有当某个进程修改了自己内存空间对应的区域，会触发一个保护异常，这时内核会再复制一份物理内存副本，供当前进程进行写操作，这就是写时拷贝（copy on write, cow）。写时复制可以最大限度上的节省物理内存资源。</li>
</ol>
<p>Linux最常见的fork函数，就是利用了这种特性，fork子进程时完全拷贝父进程的页表样本，并标记为私有的写时复制，这样只有在两个进程尝试修改内存页的时候，才会去复制新的物理内存副本。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虚拟内存是现代操作系统重要的抽象概念之一，以及与之配合的MMU、多级页表、TLB、cache、DRAM等。虚拟内存简化了内存的使用和管理，同时节省了物理内存资源。在使用和实现过程中，又结合了计算机领域的多个重要概念，比如程序的局部性原理，存储器层次结构，写时复制，swap等等，能更好的帮助理解操作系统的整体运行机制。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">furthergo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://github.com/furthergo/2020/06/05/virtual-memory/">https://github.com/furthergo/2020/06/05/virtual-memory/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/OS/">OS</a><a class="post-meta__tags" href="/tags/CSAPP/">CSAPP</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/06/07/what-is-autoclosure/"><i class="fa fa-chevron-left">  </i><span>什么是@autoclosure</span></a></div><div class="next-post pull-right"><a href="/2020/06/05/HowandWhyLaunch/"><span>How&amp;Why Launch</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '5172c31ed5ec5462891c',
  clientSecret: '2a57ab34b48ff0d860dd57f70547e3416ebe0d85',
  repo: 'furthergo.github.io',
  owner: 'furthergo',
  admin: 'furthergo',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(/img/bm1.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 By furthergo</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>