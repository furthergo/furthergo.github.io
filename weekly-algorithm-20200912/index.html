<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="[Weekly Algorithm]20200912: Dynamic programming II"><meta name="keywords" content="Ugly Number,Ugly Number II,Perfect Squares,Range Sum Query - Immutable,Rnage Sum Query 2D - Imuutable,Best Time to Buy and Sell Stock,Best Time to Buy and Sell Stock II,Best Time to Buy and Sell Stock with Cooldown,Coin Change,Integer Break,Count Numbers with Unique Digits"><meta name="author" content="furthergo"><meta name="copyright" content="furthergo"><title>[Weekly Algorithm]20200912: Dynamic programming II | furthergo</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.8.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.8.2"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.8.2"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><meta name="google-site-verification" content="oQkdLBTArbDoNq8FA6P9TiTYGdELfAVbSvkRTq9Heps"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '4.2.1'
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0x00-本周刷题总结"><span class="toc-number">1.</span> <span class="toc-text">0x00 本周刷题总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x01-Ugly-Number-and-Ugly-Number-II"><span class="toc-number">2.</span> <span class="toc-text">0x01 Ugly Number and Ugly Number II</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Ugly-Number"><span class="toc-number">2.1.</span> <span class="toc-text">Ugly Number</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#分析与求解"><span class="toc-number">2.1.1.</span> <span class="toc-text">分析与求解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ugly-Number-II"><span class="toc-number">2.2.</span> <span class="toc-text">Ugly Number II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#思路分析"><span class="toc-number">2.2.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#问题求解"><span class="toc-number">2.2.2.</span> <span class="toc-text">问题求解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x02-Perfect-Squares"><span class="toc-number">3.</span> <span class="toc-text">0x02 Perfect Squares</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#思路分析-1"><span class="toc-number">3.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#求解"><span class="toc-number">3.2.</span> <span class="toc-text">求解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x03-Range-Sum-Query-and-Rnage-Sum-Query-2D"><span class="toc-number">4.</span> <span class="toc-text">0x03 Range Sum Query and Rnage Sum Query 2D</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Range-Sum-Query"><span class="toc-number">4.1.</span> <span class="toc-text">Range Sum Query</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#分析求解"><span class="toc-number">4.1.1.</span> <span class="toc-text">分析求解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rnage-Sum-Query-2D"><span class="toc-number">4.2.</span> <span class="toc-text">Rnage Sum Query 2D</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#分析求解-1"><span class="toc-number">4.2.1.</span> <span class="toc-text">分析求解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x04-Best-Time-to-Buy-and-Sell-Stock-II-with-cooldown"><span class="toc-number">5.</span> <span class="toc-text">0x04 Best Time to Buy and Sell Stock &#x2F; II &#x2F; with cooldown</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Best-Time-to-Buy-and-Sell-Stock"><span class="toc-number">5.1.</span> <span class="toc-text">Best Time to Buy and Sell Stock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#分析求解-2"><span class="toc-number">5.1.1.</span> <span class="toc-text">分析求解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Best-Time-to-Buy-and-Sell-Stock-II"><span class="toc-number">5.2.</span> <span class="toc-text">Best Time to Buy and Sell Stock II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#思路分析-2"><span class="toc-number">5.2.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#问题求解-1"><span class="toc-number">5.2.2.</span> <span class="toc-text">问题求解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><span class="toc-number">5.3.</span> <span class="toc-text">Best Time to Buy and Sell Stock with Cooldown</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#思路分析-3"><span class="toc-number">5.3.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#问题求解-2"><span class="toc-number">5.3.2.</span> <span class="toc-text">问题求解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x04-Coin-Change"><span class="toc-number">6.</span> <span class="toc-text">0x04 Coin Change</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#分析求解-3"><span class="toc-number">6.1.</span> <span class="toc-text">分析求解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x05-Integer-Break"><span class="toc-number">7.</span> <span class="toc-text">0x05 Integer Break</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#分析求解-4"><span class="toc-number">7.1.</span> <span class="toc-text">分析求解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x05-Count-Numbers-with-Unique-Digits"><span class="toc-number">8.</span> <span class="toc-text">0x05 Count Numbers with Unique Digits</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#思路分析-4"><span class="toc-number">8.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#问题求解-3"><span class="toc-number">8.2.</span> <span class="toc-text">问题求解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x06-总结"><span class="toc-number">9.</span> <span class="toc-text">0x06 总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.JPG"></div><div class="author-info__name text-center">furthergo</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/furthergo" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">9</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">5</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">2</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/1.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">furthergo</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/sitemap.xml || sitemap">Sitemap</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">[Weekly Algorithm]20200912: Dynamic programming II</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-09-13</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Weekly-Algorithm/">Weekly Algorithm</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="0x00-本周刷题总结"><a href="#0x00-本周刷题总结" class="headerlink" title="0x00 本周刷题总结"></a>0x00 本周刷题总结</h1><ul>
<li>一共刷了11道题，主要还是DP专题，有一些题比如买股票的题目类似，为了理解题意和其中的差距，把之前的题也一起做了</li>
<li>收获：理解DP的常见套路 </li>
<li>这周的部分分析不会这么细，比较浪费时间，相同题型或者某些优化点不再赘述。</li>
</ul>
<h1 id="0x01-Ugly-Number-and-Ugly-Number-II"><a href="#0x01-Ugly-Number-and-Ugly-Number-II" class="headerlink" title="0x01 Ugly Number and Ugly Number II"></a>0x01 <a href="https://leetcode.com/problems/ugly-number/" target="_blank" rel="noopener">Ugly Number</a> and <a href="https://leetcode.com/problems/ugly-number-ii/" target="_blank" rel="noopener">Ugly Number II</a></h1><h2 id="Ugly-Number"><a href="#Ugly-Number" class="headerlink" title="Ugly Number"></a><a href="https://leetcode.com/problems/ugly-number/" target="_blank" rel="noopener">Ugly Number</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">检查输入的正整数num是否是Ugly数，Ugly数的定义是一个质因子只有2、3、5的正整数。</span><br></pre></td></tr></table></figure>
<h3 id="分析与求解"><a href="#分析与求解" class="headerlink" title="分析与求解"></a>分析与求解</h3><p>难度是Easy，分析一下可以得出解题思路：不断的尝试用2、3、5整除数字num，知道2、3、5都无法被整除或者num被除到1，代码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isUgly</span><span class="params">(num <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> num &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span> ; num&gt;<span class="number">1</span>;  &#123;</span><br><span class="line">        <span class="keyword">if</span> num%<span class="number">5</span> == <span class="number">0</span> &#123;</span><br><span class="line">            num /= <span class="number">5</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> num%<span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">            num /= <span class="number">3</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> num%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">            num /= <span class="number">2</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Ugly-Number-II"><a href="#Ugly-Number-II" class="headerlink" title="Ugly Number II"></a><a href="https://leetcode.com/problems/ugly-number-ii/" target="_blank" rel="noopener">Ugly Number II</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入n，输出第n个Ugly Number，Ugly数的定义是一个质因子只有2、3、5的正整数。</span><br></pre></td></tr></table></figure>

<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><ul>
<li><p>常规的暴力方法是，从1开始步长为1遍历，分别计算每个数是否是Ugly Number并累计，直到第n个。但是对于每个数字，计算它是否是Ugly Number的时候，都要不断的用2、3、5除它，时间复杂度很高；之后我也尝试把计算过程中每个数是否是Ugly Number的计算结果存在数组里，给之后的数使用，结果是<a href="https://leetcode.com/submissions/detail/391586808/" target="_blank" rel="noopener">out of memory</a>。</p>
</li>
<li><p>思考了一下根本原因， 还是求Ugly Number的时候都是乘法关系，这样越往后就会越稀疏，步长为1的遍历效率过于低了。</p>
</li>
<li><p>生产者模式：我们可以换一个角度思考问题，遍历加校验的方式，其实是消费者的角度，不断的消费每个数，从中过滤出Ugly Number。既然消费者的角度行不通，我们可以从生产者的角度去求解，即尝试去<strong>生产Ugly Number</strong>。</p>
</li>
<li><p>我们用已有的Ugly Number，乘以2、3、5，就可以产生新的Ugly Number，然后存下来，再用这些数继续生成新的Ugly Number这样的时间复杂度和空间复杂度都降到了O(n)。</p>
</li>
</ul>
<h3 id="问题求解"><a href="#问题求解" class="headerlink" title="问题求解"></a>问题求解</h3><ul>
<li><p>我们用一个数组dp[n]来存储已经得到的Ugly Number，一开始我们只有一个Ugly Number即，取出1乘以2，3，5生成了三个Ugly Number，因为题目是求的第n个Ugly Number，所以我们要保证存在dp中的数组的有序性，这里取2、3、5其中最小的数2添加到dp数组的末尾。</p>
</li>
<li><p>下一次我们取其中最小的数2然后分别乘以2、3、5得到4、6、10，这是可以发现，3和5还没有被放进dp数组中，因为上一个Ugly Number即1所生产的Ugly Number还没有全部被消费到dp数组里，即当前用来生产乘2的种子是2，但是生产乘3和乘5的种子还是1。这里我们取出2乘以2，取出1乘以3和5，得到3个4、3、5，我们取出最小的数3添加到dp数组的末尾。以此类推下次我们应该消费种子2乘以2和3，种子1乘以5，得到4、6、5三个数，取出最小的数4添加到dp数组的末尾……</p>
</li>
<li><p>归纳一下上述的过程，我们需要一个dp数组存储所有已经生产的Ugly Number；其次我们需要三个index，分别记录应该用来乘2、3、5的种子的位置，这样才能保证所有Ugly Number被有序的添加到dp数组中</p>
</li>
</ul>
<p>实现代码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123; <span class="keyword">return</span> b &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nthUglyNumber</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    <span class="comment">//idx记录2、3、5应该使用的种子的位置</span></span><br><span class="line">	idx2 := <span class="number">0</span></span><br><span class="line">	idx3 := <span class="number">0</span></span><br><span class="line">	idx5 := <span class="number">0</span></span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i&lt;n; i++ &#123;</span><br><span class="line">		c2 := dp[idx2] * <span class="number">2</span></span><br><span class="line">		c3 := dp[idx3] * <span class="number">3</span></span><br><span class="line">		c5 := dp[idx5] * <span class="number">5</span></span><br><span class="line"></span><br><span class="line">        dp[i] = min(min(c2, c3), c5)</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">if</span> c2 == dp[i] &#123; idx2++ &#125;</span><br><span class="line">		<span class="keyword">if</span> c3 == dp[i] &#123; idx3++ &#125; </span><br><span class="line">		<span class="keyword">if</span> c5 == dp[i] &#123; idx5++ &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[n<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 注意这里迭代idx的方式，我们是判断c2、c3和c5是否和新添加进dp数组的数相等来更新对应的idx。因为对于一些数就是2、3、5相乘的结果的时候，比如6=2x3=3x2，10=2x5=5x2，这些数在计算过程中会重复出现，即c2、c3、c5可能会相等，通过这种方式刚好可以避免重复添加，比如乘2的种子3和乘3的种子2结果相等，那么idx2和idx3都会向后移，代表生产的数已经被消费。</p>
<h1 id="0x02-Perfect-Squares"><a href="#0x02-Perfect-Squares" class="headerlink" title="0x02 Perfect Squares"></a>0x02 <a href="https://leetcode.com/problems/perfect-squares/" target="_blank" rel="noopener">Perfect Squares</a></h1><p>输入正整数n，求最少需要多少个完美平方数能组成它</p>
<h2 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h2><p>一道典型的DP题，计算n最少需要多少个完美平方数组成（之后简写为f(n)），我们可以尝试用n先减去一个完美平方数，得到n’，那么n可以由f(n’)+1个完美平方数组成。要求f(n)，只需要尝试所有可以用来减的完美平方数，然后求出其中的最小值，即为f(n)。状态转移方程如下：</p>
<center>f(n) = min(f(n - i*i)+1)

<p>其中i*i最大为n</center></p>
<h2 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h2><p>用dp[n]=f(n)记录中间解，其中dp[0]=0代表需要0个数组成，从1遍历至n，实现代码如下</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numSquares</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int32</span>, n+<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i&lt;=n; i++ &#123;</span><br><span class="line">        <span class="keyword">var</span> min <span class="keyword">int32</span> = <span class="keyword">int32</span>(i)</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j*j&lt;=i; j++ &#123;</span><br><span class="line">            t := <span class="number">1</span> + dp[i-j*j]</span><br><span class="line">            <span class="keyword">if</span> t &lt; min &#123;</span><br><span class="line">                min = t</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = min</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int</span>(dp[n])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="0x03-Range-Sum-Query-and-Rnage-Sum-Query-2D"><a href="#0x03-Range-Sum-Query-and-Rnage-Sum-Query-2D" class="headerlink" title="0x03 Range Sum Query and Rnage Sum Query 2D"></a>0x03 <a href="https://leetcode.com/problems/range-sum-query-immutable/" target="_blank" rel="noopener">Range Sum Query</a> and <a href="https://leetcode.com/problems/range-sum-query-2d-immutable/" target="_blank" rel="noopener">Rnage Sum Query 2D</a></h1><p>题型和题意都相同，放在一起做和分析。</p>
<h2 id="Range-Sum-Query"><a href="#Range-Sum-Query" class="headerlink" title="Range Sum Query"></a><a href="https://leetcode.com/problems/range-sum-query-immutable/" target="_blank" rel="noopener">Range Sum Query</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给一个正数数组，求i到j的数的和(i&lt;&#x3D;j)。注意数组是不可变的，且会有多次query求和</span><br></pre></td></tr></table></figure>

<h3 id="分析求解"><a href="#分析求解" class="headerlink" title="分析求解"></a>分析求解</h3><p>Easy难度，用f(n)代表当前数组0到n的数的和，则i到j的和等于f(j)-f(i-1)，因此我们只需要先求f(n)即可，而f(n)是最简单的求和，状态转移方程是<code>f(n) = f(n-1) + nums[n]</code>。实现代码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NumArray <span class="keyword">struct</span> &#123;</span><br><span class="line">    dp []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">NumArray</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    </span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i&lt;=n; i++ &#123;</span><br><span class="line">        dp[i] = dp[i<span class="number">-1</span>] + nums[i<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    r := NumArray&#123;</span><br><span class="line">        dp: dp,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *NumArray)</span> <span class="title">SumRange</span><span class="params">(i <span class="keyword">int</span>, j <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.dp[j+<span class="number">1</span>] - this.dp[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里为了简化f(0)的计算，将dp数组长度声明为n+1，即<code>f(i) = dp[i+1]</code>，在构造过程中求解dp数组，query时使用。</p>
<h2 id="Rnage-Sum-Query-2D"><a href="#Rnage-Sum-Query-2D" class="headerlink" title="Rnage Sum Query 2D"></a><a href="https://leetcode.com/problems/range-sum-query-2d-immutable/" target="_blank" rel="noopener">Rnage Sum Query 2D</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个m*n矩阵，求其中任意矩形组成的矩阵中的数字和，输入是左上角和右下角的坐标</span><br></pre></td></tr></table></figure>
<div align=center> <img src ="https://leetcode.com/static/images/courses/range_sum_query_2d.png"/> </div>

<h3 id="分析求解-1"><a href="#分析求解-1" class="headerlink" title="分析求解"></a>分析求解</h3><ul>
<li><p>和上一题类似，只是从一维变成了二维，思路还是一样，任意矩形的sum，等于以（0，0）为左上角的大矩形的sum，减去左边的矩形sum，减去上面的矩形sum，再加上多减了一次的左上角的矩形的sum。</p>
</li>
<li><p>假设输入(l,t,r,b)代表矩形，s(l,t,r,b)代表矩阵的sum，则有公式<code>s(l,t,r,b) = (0,0,r,b) - s(0,0,l-1,b) - s(0,0,r, t-1) + s(0,0,l-1, t-1)</code></p>
</li>
<li><p>接下来只需要在构造过程中计算存储s(0,0,i,j) = f(i,j) = dp[i,j]的值，和上一题类似的思路可以得到状态转移方程<code>f(i,j) = f(i-1,j) + f(i,j-1) - f(i-1,j-1) + matrix[i][j]</code></p>
</li>
</ul>
<p>实现代码如下（同样，这里为了简化计算过程中的边界case处理，把dp数组大小声明为m+1*n+1，即<code>f(i,j) = dp[i+1][j+1]</code>）：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NumMatrix <span class="keyword">struct</span> &#123;</span><br><span class="line">    dp [][]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(matrix [][]<span class="keyword">int</span>)</span> <span class="title">NumMatrix</span></span> &#123;</span><br><span class="line">    m := <span class="built_in">len</span>(matrix)</span><br><span class="line">    <span class="keyword">if</span> m == <span class="number">0</span> &#123; <span class="keyword">return</span> NumMatrix&#123;&#125;&#125;</span><br><span class="line">    n := <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="keyword">int</span>, m+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i:= <span class="number">0</span>; i&lt;=m; i++ &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i&lt;=m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j :=<span class="number">1</span>; j&lt;=n; j++ &#123;</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>] - dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + matrix[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NumMatrix &#123;</span><br><span class="line">        dp: dp,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *NumMatrix)</span> <span class="title">SumRegion</span><span class="params">(row1 <span class="keyword">int</span>, col1 <span class="keyword">int</span>, row2 <span class="keyword">int</span>, col2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.dp[row2+<span class="number">1</span>][col2+<span class="number">1</span>] - this.dp[row1][col2+<span class="number">1</span>] - this.dp[row2+<span class="number">1</span>][col1] + this.dp[row1][col1]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="0x04-Best-Time-to-Buy-and-Sell-Stock-II-with-cooldown"><a href="#0x04-Best-Time-to-Buy-and-Sell-Stock-II-with-cooldown" class="headerlink" title="0x04 Best Time to Buy and Sell Stock / II / with cooldown"></a>0x04 <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">Best Time to Buy and Sell Stock</a> / <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">II</a> / <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">with cooldown</a></h1><p>三道买卖股票的题。</p>
<h2 id="Best-Time-to-Buy-and-Sell-Stock"><a href="#Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="Best Time to Buy and Sell Stock"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">Best Time to Buy and Sell Stock</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定数组prices，长度为n，代表股票每天的价格，可以在任意天买入和卖出股票各一次。问能得到的最大利润是多少？</span><br></pre></td></tr></table></figure>

<h3 id="分析求解-2"><a href="#分析求解-2" class="headerlink" title="分析求解"></a>分析求解</h3><p>最低点买入，最高点卖出即可，代码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    n := <span class="built_in">len</span>(prices)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123; <span class="keyword">return</span> res &#125;</span><br><span class="line">    min := prices[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;n ; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> prices[i] &lt; min &#123; <span class="comment">// 尝试更新股票最小价格</span></span><br><span class="line">            min = prices[i] </span><br><span class="line">        &#125; </span><br><span class="line">        t := prices[i] - min <span class="comment">// 尝试更新最大利润</span></span><br><span class="line">        <span class="keyword">if</span> t &gt; res &#123;</span><br><span class="line">            res = t</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Best-Time-to-Buy-and-Sell-Stock-II"><a href="#Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="Best Time to Buy and Sell Stock II"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">Best Time to Buy and Sell Stock II</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定数组prices，长度为n，代表股票每天的价格，可以在任意天买入和卖出股票多次。问能得到的最大利润是多少？</span><br></pre></td></tr></table></figure>

<h3 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h3><p>比上一题多了一个条件：可以多次买入和卖出，我们来结合上一题分析一下。</p>
<ul>
<li>上一题最大利润的计算其实就是找到最大最小值，然后求差。即我们把股票的价格波动当做一个个山峰和山谷，上一题就是找到最高的山峰和最低的山谷，然后求高度之差。（当然这里都是要求山峰在后）</li>
<li>这一题可以买卖多次，很直观的可以想到，我们只需要在低点买入，高点卖出，然后不断重复这个操作，就可以获得最大值。类比之下，就相当于现在要找的不是股票价格的最大值和最小值，而是股票价格的极大值和极小值。</li>
<li>但是当我们开始写代码时候会发现，求极大极小值过于麻烦，我们再重新抽象分析问题，寻找更利于代码实现的解题方式：<ol>
<li>当今天我们处于空仓时（手上没有股票），首先要做的是买入股票</li>
<li>当今天我们处于持仓时（已买入股票），依据明天股票的价格，我们有两种选择：<ul>
<li>明天的股票价格比今天的低，那么今天的持仓必须在今天卖掉，这样我就能保证手上持有的股票收益达到最高</li>
<li>明天的股票价格比今天的高，那么至少在明天卖我可以赚钱，所以继续持有</li>
<li>特殊的，当今天是最后一天时，必须卖出股票</li>
</ul>
</li>
<li>重复12步骤</li>
</ol>
</li>
</ul>
<h3 id="问题求解-1"><a href="#问题求解-1" class="headerlink" title="问题求解"></a>问题求解</h3><p>我们用一个数记录当前持仓的股票买入时的价格，-1代表空仓，用res记录当前的利润，实现代码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(prices)</span><br><span class="line">    </span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    buy := <span class="number">-1</span> <span class="comment">// 持仓价格，-1代表空仓</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> buy == <span class="number">-1</span> &#123;</span><br><span class="line">            buy = prices[i] <span class="comment">// 空仓时必须买入</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> i == n<span class="number">-1</span> || prices[i] &gt;= prices[i+<span class="number">1</span>]  &#123; <span class="comment">// 今天是最后一天或者明天价格会降，以今天的价格卖出，更新收益</span></span><br><span class="line">            res += (prices[i] - buy)</span><br><span class="line">            buy = <span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则，继续持有买入价为buy的股票</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><a href="#Best-Time-to-Buy-and-Sell-Stock-with-Cooldown" class="headerlink" title="Best Time to Buy and Sell Stock with Cooldown"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">Best Time to Buy and Sell Stock with Cooldown</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定数组prices，长度为n，代表股票每天的价格，可以在任意买入和卖出股票多次，但是卖出之后需要有一天的冷冻时间，然后才能买入。问能得到的最大利润是多少？</span><br></pre></td></tr></table></figure>

<h3 id="思路分析-3"><a href="#思路分析-3" class="headerlink" title="思路分析"></a>思路分析</h3><p>加入了一个cooldown之后，买入的条件是，前一天不能有卖出，那么卖出的时机就会影响到下一次买入的时机，也就会影响到下一次的获利。状态变得复杂了。下面我们来分析一下怎么通过dp来解这道题：</p>
<ul>
<li>买入的时机受卖出时机的影响</li>
<li>卖出的时机受买入的影响</li>
<li>卖出之后需要有至少一天的空仓期</li>
</ul>
<p>综上我们分析出现在有三种状态：</p>
<ol>
<li>空仓（可买入）</li>
<li>持仓</li>
<li>刚清仓 （需要cooldown）</li>
</ol>
<p>三种状态可能的转移方式分别是：</p>
<ul>
<li>1 -&gt; 1，继续空仓</li>
<li>3 -&gt; 1，刚过cooldown的空仓</li>
<li>1 -&gt; 2，空仓状态下买入，转移为持仓</li>
<li>2 -&gt; 2，继续持仓</li>
<li>2 -&gt; 3，卖出</li>
</ul>
<p>根据状态转移，<code>我们可以遍历价格数组，计算每天是每个状态的最大收益，最后一天求三个状态最大收益的最大值，就是最后的最大收益</code>。假设：</p>
<ul>
<li>e(n)代表第n天空仓的最大收益</li>
<li>b(n)代表第n天是持仓的最大收益</li>
<li>c(n)代表第n天是cooldown状态的最大收益</li>
</ul>
<p>根据上面的状态转移方式，我们可以得到三个状态转移方程：</p>
<ul>
<li>e(n) = max(e(n-1), c(n-1))</li>
<li>b(n) = max(e(n-1), b(n-1) - prices[n])</li>
<li>c(n) = b(n-1) + prices[n]</li>
</ul>
<h3 id="问题求解-2"><a href="#问题求解-2" class="headerlink" title="问题求解"></a>问题求解</h3><p>根据上面的分析我们维护三个长度为n的dp数组分别代表上面三种状态的最大值，并且每次转移只依赖上一次的状态，我们可以压缩空间复杂度至O(1)，实现代码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123; <span class="keyword">return</span> a &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(prices)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录当前进行操作的最大收益</span></span><br><span class="line">    dpEmpty := <span class="number">0</span> <span class="comment">// 当前是空仓</span></span><br><span class="line">    dpBuyed := -prices[<span class="number">0</span>] <span class="comment">// 当前是持仓</span></span><br><span class="line">    dpSelled := <span class="number">0</span> <span class="comment">// 当前处于刚清仓状态（需要cooldown冷静）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        dpEmptyT := max(dpEmpty, dpSelled) <span class="comment">// 等于前一个是空仓或者selled的最大值</span></span><br><span class="line">        dpBuyedT := max(dpEmpty - prices[i], dpBuyed) <span class="comment">// 等于今天新买入或者前一天是持仓的最大值</span></span><br><span class="line">        dpSelledT := dpBuyed + prices[i] <span class="comment">// 等于前一个是持仓状态加上今天的卖出收益</span></span><br><span class="line">        </span><br><span class="line">        dpEmpty = dpEmptyT</span><br><span class="line">        dpBuyed = dpBuyedT</span><br><span class="line">        dpSelled = dpSelledT</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> max(dpEmpty, max(dpBuyed, dpSelled))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于这道题的解题思路，非常建议看一下讨论区的这个<a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/75928/Share-my-DP-solution-(By-State-Machine-Thinking)" target="_blank" rel="noopener">回答</a>，看图理解可能会更清晰，我就是看了他的图瞬间找到了解题的实现方法~~</p>
<h1 id="0x04-Coin-Change"><a href="#0x04-Coin-Change" class="headerlink" title="0x04 Coin Change"></a>0x04 <a href="https://leetcode.com/problems/coin-change/" target="_blank" rel="noopener">Coin Change</a></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一组不同面额的硬币coins和一个钱的总金额amount，计算最少需要多少枚硬币能组成这个总金额。如果不能组成，返回-1</span><br></pre></td></tr></table></figure>

<h2 id="分析求解-3"><a href="#分析求解-3" class="headerlink" title="分析求解"></a>分析求解</h2><p>f(n)代表组成n所需要的最少硬币个数，求解f(n)时，可以遍历coins数组，用n减去硬币的面额得到n’，则f(n)可能等于f(n’)+1。我们可以得到状态转移方程：</p>
<center>f(n)=min(f(n-coins[i]))

<p>其中i从0到len(coins)</center><br>需要注意的是n可能小于coins[i]，这时候不应该被计算。<br>实现代码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123; <span class="keyword">return</span> b &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coinChange</span><span class="params">(coins []<span class="keyword">int</span>, amount <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, amount + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span> </span><br><span class="line">    sort.Ints(coins)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i&lt;=amount; i++ &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span>&lt;&lt;<span class="number">32</span></span><br><span class="line">        <span class="keyword">for</span> _, coin := <span class="keyword">range</span> coins &#123;</span><br><span class="line">            <span class="keyword">if</span> coin &lt;= i &#123;</span><br><span class="line">                dp[i] = min(dp[i], dp[i-coin] + <span class="number">1</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r := dp[amount]</span><br><span class="line">    <span class="keyword">if</span> r &gt; amount &#123; <span class="comment">// 无法组成amount</span></span><br><span class="line">        r = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="0x05-Integer-Break"><a href="#0x05-Integer-Break" class="headerlink" title="0x05 Integer Break"></a>0x05 <a href="https://leetcode.com/problems/integer-break/" target="_blank" rel="noopener">Integer Break</a></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定整数n，分成至少两个正整数的和，求这些数的乘积的最大值。其中2&lt;&#x3D; n &lt;&#x3D;58</span><br></pre></td></tr></table></figure>

<h2 id="分析求解-4"><a href="#分析求解-4" class="headerlink" title="分析求解"></a>分析求解</h2><p>用f(n)代表n能求得的最大乘积，求f(n)的时候，可以先用n减去一个数i，则f(n)可能等于f(n-i)*i，遍历i从1到n-1，求出最大值，即状态转移方程是：</p>
<center>f(n)=max(f(n-i)*i)

<p>其中i从1到n-1</center></p>
<p>实现代码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123; <span class="keyword">return</span> a &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">integerBreak</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i&lt;=n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i &lt; n &#123;</span><br><span class="line">            dp[i] = i <span class="comment">// if i is less than n, it can be used as a single num, which mean it's max product at least is i</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> j := i<span class="number">-1</span>; j &gt;= <span class="number">1</span>; j-- &#123;</span><br><span class="line">            dp[i] = max(dp[i], dp[i-j]*j)    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意注释那里，对于所有小于n的数，可以单独的被拆成一个数来参与乘积，即<strong>dp[i]至少是i，当i&lt;n时</strong>。</p>
<h1 id="0x05-Count-Numbers-with-Unique-Digits"><a href="#0x05-Count-Numbers-with-Unique-Digits" class="headerlink" title="0x05 Count Numbers with Unique Digits"></a>0x05 <a href="https://leetcode.com/problems/count-numbers-with-unique-digits/" target="_blank" rel="noopener">Count Numbers with Unique Digits</a></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定非负整数n，计算所有不包含重复数字的数x的个数，其中0&lt;&#x3D;x&lt;10^n</span><br></pre></td></tr></table></figure>

<h2 id="思路分析-4"><a href="#思路分析-4" class="headerlink" title="思路分析"></a>思路分析</h2><p>比较有意思的一道题，一开始思路一直是在找重复的数字，然后用所有的数的个数减去重复的数字的个数，但是重复数字的生成，由于新插入的位数的位置变化过于复杂。正确的思路应该是去生成不包含重复数字的个数，下面来分析一下：</p>
<ul>
<li>i为0时，只有一个一位数字0，即<code>f(0)=0</code></li>
<li>i为1时，有0到9十个一位数字，即<code>f(1)=10</code></li>
<li>i为2时，除了n为1时的10个一位数字，还有新的可以生成的两位数字：<ul>
<li>其中两位数的第一位不能为0，所以是1到9共9种选择</li>
<li>第二位不能与第一位相同，则有10-1=9种选择</li>
<li>即两位数共有9*(10-1)种</li>
<li>即n等于2时，不包含重复数字的数共有所有的一位数加两位数：<code>f(2) = f(1) + 9*(10-1)</code></li>
</ul>
</li>
<li>i为3时，除了n为2时的一位数和二位数，还可以生成新的三位数，为9<em>(10-1)</em>(10-2)，即<code>f(3) = f(2) + 9*(10-1)*(10-2)</code></li>
<li>……</li>
<li>i为n时，除了i为n-1时的一位数和二位数……n-1位数，还可以生成新的n位数，为9<em>(10-1)</em>(10-2)<em>……(10-(n-1))，即`f(n) = f(n-1) + 9</em>(10-1)<em>(10-2)</em>……(10-(n-1))`</li>
</ul>
<p>至此我们得出来状态转移方程。</p>
<h2 id="问题求解-3"><a href="#问题求解-3" class="headerlink" title="问题求解"></a>问题求解</h2><p>维护dp数组记录f(n)，由于这里每次只依赖前一位的状态，可以优化空间复杂度为O(1)。此外注意这里每次新生成的n位数的个数，等于之前的n-1位数的个数乘以10-(n-1)，可以同时记录这个变量，实现代码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countNumbersWithUniqueDigits</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;</span><br><span class="line">    </span><br><span class="line">    r := <span class="number">10</span></span><br><span class="line">    t := <span class="number">9</span> <span class="comment">// 第一位是只有9中选择</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i&lt;=n; i++ &#123;</span><br><span class="line">        t *= (<span class="number">10</span> - i + <span class="number">1</span>) <span class="comment">// 之后每位有10 - (i - 1)种</span></span><br><span class="line">        r += t</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h1><p>本周又遇到了新的题型，有了新的解题思路，其中我非常详细的写了三道题的思路分析，我认为解题的思路比较有意思或者比较新颖，可以仔细的看一下。</p>
<ul>
<li><a href="https://leetcode.com/problems/ugly-number-ii/" target="_blank" rel="noopener">Ugly Number II</a></li>
<li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">Best Time to Buy and Sell Stock with Cooldown</a></li>
<li><a href="https://leetcode.com/problems/count-numbers-with-unique-digits/" target="_blank" rel="noopener">Count Numbers with Unique Digits</a></li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">furthergo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://furthergo.github.io/weekly-algorithm-20200912/">https://furthergo.github.io/weekly-algorithm-20200912/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/algorithm/">algorithm</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/weekly-algorithm-20200919/"><i class="fa fa-chevron-left">  </i><span>[Weekly Algorithm]20200919: Dynamic programming III</span></a></div><div class="next-post pull-right"><a href="/weekly-algorithm-20200905/"><span>[Weekly algorithm]20200905: Dynamic programming</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '5172c31ed5ec5462891c',
  clientSecret: '2a57ab34b48ff0d860dd57f70547e3416ebe0d85',
  repo: 'furthergo.github.io',
  owner: 'furthergo',
  admin: 'furthergo',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(/img/1.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 By furthergo</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.8.2"></script><script src="/js/fancybox.js?version=1.8.2"></script><script src="/js/sidebar.js?version=1.8.2"></script><script src="/js/copy.js?version=1.8.2"></script><script src="/js/fireworks.js?version=1.8.2"></script><script src="/js/transition.js?version=1.8.2"></script><script src="/js/scroll.js?version=1.8.2"></script><script src="/js/head.js?version=1.8.2"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>