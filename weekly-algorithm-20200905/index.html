<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="[Weekly algorithm]20200905: Dynamic programming"><meta name="keywords" content="algorithm,leetcode,Unique Paths,Decode Ways,Unique Binary Search Trees,Word Break,Maximum Product Subarray,House Robber,Maximal Square"><meta name="author" content="furthergo"><meta name="copyright" content="furthergo"><title>[Weekly algorithm]20200905: Dynamic programming | furthergo</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.8.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.8.2"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.8.2"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><meta name="google-site-verification" content="oQkdLBTArbDoNq8FA6P9TiTYGdELfAVbSvkRTq9Heps"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '4.2.1'
} </script><meta name="generator" content="Hexo 4.2.1"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0x00"><span class="toc-number">1.</span> <span class="toc-text">0x00</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x01"><span class="toc-number">2.</span> <span class="toc-text">0x01</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Unique-Paths"><span class="toc-number">2.1.</span> <span class="toc-text">Unique Paths</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#思路分析"><span class="toc-number">2.1.1.</span> <span class="toc-text">思路分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结"><span class="toc-number">2.1.2.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Minmium-Path-Sum"><span class="toc-number">2.2.</span> <span class="toc-text">Minmium Path Sum</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#分析求解"><span class="toc-number">2.2.1.</span> <span class="toc-text">分析求解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Decode-Ways"><span class="toc-number">2.3.</span> <span class="toc-text">Decode Ways</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#分析求解-1"><span class="toc-number">2.3.1.</span> <span class="toc-text">分析求解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优化"><span class="toc-number">2.3.2.</span> <span class="toc-text">优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unique-Binary-Search-Trees"><span class="toc-number">2.4.</span> <span class="toc-text">Unique Binary Search Trees</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#分析求解-2"><span class="toc-number">2.4.1.</span> <span class="toc-text">分析求解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Word-Break"><span class="toc-number">2.5.</span> <span class="toc-text">Word Break</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#分析求解-3"><span class="toc-number">2.5.1.</span> <span class="toc-text">分析求解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Maximum-Product-Subarray"><span class="toc-number">2.6.</span> <span class="toc-text">Maximum Product Subarray</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#分析求解-4"><span class="toc-number">2.6.1.</span> <span class="toc-text">分析求解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#House-Robber-and-House-Robber-II"><span class="toc-number">2.7.</span> <span class="toc-text">House Robber and House Robber II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#分析求解-5"><span class="toc-number">2.7.1.</span> <span class="toc-text">分析求解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#House-Robber-II"><span class="toc-number">2.7.2.</span> <span class="toc-text">House Robber II</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Maximal-Square"><span class="toc-number">2.8.</span> <span class="toc-text">Maximal Square</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#分析求解-6"><span class="toc-number">2.8.1.</span> <span class="toc-text">分析求解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#坑"><span class="toc-number">2.8.2.</span> <span class="toc-text">坑</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#EOF"><span class="toc-number">3.</span> <span class="toc-text">EOF</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.JPG"></div><div class="author-info__name text-center">furthergo</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/furthergo" target="_blank" rel="noopener">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">7</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">5</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">2</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/1.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">furthergo</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/sitemap.xml || sitemap">Sitemap</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">[Weekly algorithm]20200905: Dynamic programming</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-09-05</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Weekly-Algorithm/">Weekly Algorithm</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h1><p>本周刷题总结：</p>
<ul>
<li>本周刷题集中在动态规划专题，语言是Golang</li>
<li>一共刷了八道题，全部是medium</li>
<li>收获：了解基础的动态规划题型，掌握了基本的解题套路和优化方式</li>
</ul>
<h1 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h1><p>下面就针对每一道题大概写一下解题思路，权当复习和巩固知识。</p>
<h2 id="Unique-Paths"><a href="#Unique-Paths" class="headerlink" title="Unique Paths"></a><a href="https://leetcode.com/problems/unique-paths/" target="_blank" rel="noopener">Unique Paths</a></h2><p><code>给一个m*n的矩阵，计算从左上角走到右下角共有多少种走法，每一步只能向右或者向下走。</code></p>
<div align=center> <img src ="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png"/> </div>

<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><ul>
<li>状态方程：<br>对于走到矩阵第i,j点来说，有两种走法，从i-1,j或者从i,j-1，因此设f(i,j)为走到点i,j的走法，则：f(i,j) = f(i-1, j) + f(i, j-1)</li>
<li>求解：用一个m*n的dp数组存储走到点i,j的走法，遍历求解<code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code>，时间复杂度和空间复杂度为<code>O(mn)</code>。dp初始化全部为1，然后i,j从1开始遍历，因为第一列和第一行的每个点都只有一种走法<a id="more"></a>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">uniquePaths</span><span class="params">(m <span class="keyword">int</span>, n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   dp := <span class="built_in">make</span>([][]<span class="keyword">int</span>, m)</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i&lt;m; i++ &#123;</span><br><span class="line">       dp[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">       <span class="keyword">for</span> j := <span class="number">0</span>; j&lt;n; j++ &#123;</span><br><span class="line">           dp[i][j] = <span class="number">1</span></span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i&lt;m; i++ &#123;</span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">1</span>; j&lt;n; j++ &#123;</span><br><span class="line">		dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>]</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li>优化：观察代码可以知道，求dp[i][j]的时候，依赖dp[i-1][j]和dp[i][j-1]的值，因此可以只用两个长度为m的数组来存储这两行状态，空间复杂度为O(2n) = O(n)，这是一种常见的DP空间压缩方式<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uniquePaths</span><span class="params">(m <span class="keyword">int</span>, n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, n) <span class="comment">// 前一行</span></span><br><span class="line">    dp1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, n) <span class="comment">// 当前行</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j&lt;n; j++ &#123;</span><br><span class="line">        dp[j] = <span class="number">1</span></span><br><span class="line">        dp1[j] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i&lt;m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j&lt;n; j++ &#123;</span><br><span class="line">            dp1[j] = dp[j] + dp1[j<span class="number">-1</span>] <span class="comment">// dp[j]代表上边；dp1[j-1]代表左边	</span></span><br><span class="line">        &#125;</span><br><span class="line">        dp = dp1 <span class="comment">// 每行遍历结束更新前一行dp</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp1[n<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>优化more： 在观察代码<code>dp1[j] = dp[j] + dp1[j-1]</code>，发现求dp1[j]时，dp[j]其实是在上一次行遍历结束时<code>dp = dp1</code>从dp1那里得到的，即dp[j] = dp1[j]，因此这里可以优化成 <code>dp1[j] = dp1[j] + dp1[j-1]</code>，这时就可以发现，这个状态转移方程里只有一个数组dp1，因此我们可以进一步优化内存占用<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uniquePaths</span><span class="params">(m <span class="keyword">int</span>, n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i&lt;n; i++ &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i&lt;m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j&lt;n; j++ &#123;</span><br><span class="line">            dp[j] += dp[j<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>为什么用dp？如果这道题用递归，写法也很简单，但是在计算f(i,j-1)和f(i-1,j)时都会计算一遍f(i-1,j-1)，产生重复计算，。动态规划就是使用空间换时间的思想，在求解依赖子问题时，使用dp数组存储子问题解，避免重复计算。而在实现过程中，又可以根据我们所需要依赖的子问题的状态，进一步优化空间，达到最优解。</p>
<h2 id="Minmium-Path-Sum"><a href="#Minmium-Path-Sum" class="headerlink" title="Minmium Path Sum"></a><a href="https://leetcode.com/problems/minimum-path-sum/" target="_blank" rel="noopener">Minmium Path Sum</a></h2><p><code>还是m*n的矩阵，每个点有一个非负整数，和上题一样的走法，计算左上角到右下角最小路径和。</code></p>
<h3 id="分析求解"><a href="#分析求解" class="headerlink" title="分析求解"></a>分析求解</h3><p>这道题和上题的思路类似，加上了每次路径的和，因为要求最小值，可以得到状态转移方程<code>f(i,j) = min(f(i-1,j), f(i, j-1)) + v(i, j)</code>。实现代码如下, 时间复杂度为O(mn)，空间复杂度为O(n)</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minPathSum</span><span class="params">(grid [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	m := <span class="built_in">len</span>(grid)</span><br><span class="line">	n := <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">    dp[<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>] <span class="comment">// 出发点</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span> j:= <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">		dp[j] = dp[j<span class="number">-1</span>] + grid[<span class="number">0</span>][j] <span class="comment">// 先处理第一行，第一行只有从左往右的走法</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; m; i++ &#123; <span class="comment">// 从第二行开始遍历</span></span><br><span class="line">		dp[<span class="number">0</span>] +=grid[i][<span class="number">0</span>] <span class="comment">// 每行第一个点，只有从上往下的走法</span></span><br><span class="line">		<span class="keyword">for</span> j:= <span class="number">1</span>; j &lt; n; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> dp[j<span class="number">-1</span>] &lt; dp[j] &#123; <span class="comment">// dp[j]代表的是从上往下的走法，尝试用从左往右的走法更新dp[j]</span></span><br><span class="line">				dp[j] = dp[j<span class="number">-1</span>]</span><br><span class="line">			&#125;</span><br><span class="line">			dp[j] += grid[i][j]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[n<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Decode-Ways"><a href="#Decode-Ways" class="headerlink" title="Decode Ways"></a><a href="https://leetcode.com/problems/decode-ways/" target="_blank" rel="noopener">Decode Ways</a></h2><p><code>一串数字组成的数字串，数字可以映射到字母，1-26代表字母A-Z，问字符串s映射到字母串有多少种映射方式？</code></p>
<h3 id="分析求解-1"><a href="#分析求解-1" class="headerlink" title="分析求解"></a>分析求解</h3><p>这是一道一维dp，对于位置的数字s[i]来说，它的映射方式依赖s[i-1]的值，可以单独映射成一个字母，也可以和前一个数一起一起组成两位数映射到字母。有两种可能：</p>
<ol>
<li>它可以自己映射为一个字母，需要s[i]不为0</li>
<li>它可以和前一个数字一起映射为一个字母，组成的数字是10到26，需要s[i-1]为1或者s[i-1]为2且s[i]小于等于6。</li>
</ol>
<p>因此状态转移方程是</p>
<center>f(i) = ff(i-1) + ff(i-2)</center>
其中
<center>ff(i-1) = f(i-1)*(s[i]!=0)</center>
<center>ff(i-2) = f(i-2) * (s(i-1)==1 || (s(i-1)==2&&s[i]<7))</center>

<p>实现代码如下，时间复杂度和空间复杂度为O(n)</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numDecodings</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">'0'</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i&lt;=n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i<span class="number">-1</span>] == <span class="string">'0'</span> &#123;</span><br><span class="line">            dp[i] = <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> s[i<span class="number">-2</span>] == <span class="string">'1'</span> || (s[i<span class="number">-2</span>] == <span class="string">'2'</span> &amp;&amp; s[i<span class="number">-1</span>] &lt; <span class="string">'7'</span>) &#123;</span><br><span class="line">            dp[i] += dp[i<span class="number">-2</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为对于每个i来说，需要依赖dp(i-1)和dp(i-2)的状态，为了简化和统一计算dp(1)，在将dp数组声明成n+1，且dp[0] = 1。</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numDecodings</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">'0'</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pre := <span class="number">1</span></span><br><span class="line">    prepre := <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i&lt;=n; i++ &#123;</span><br><span class="line">        t := <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> s[i<span class="number">-1</span>] == <span class="string">'0'</span> &#123;</span><br><span class="line">            t = <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            t = pre</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> s[i<span class="number">-2</span>] == <span class="string">'1'</span> || (s[i<span class="number">-2</span>] == <span class="string">'2'</span> &amp;&amp; s[i<span class="number">-1</span>] &lt; <span class="string">'7'</span>) &#123;</span><br><span class="line">            t += prepre</span><br><span class="line">        &#125;</span><br><span class="line">        prepre = pre</span><br><span class="line">        pre = t</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为dp[i]只依赖dp[i-1]和dp[i-2]，因此可以用两个变量来存储，优化空间复杂度为O(1)。</p>
<h2 id="Unique-Binary-Search-Trees"><a href="#Unique-Binary-Search-Trees" class="headerlink" title="Unique Binary Search Trees"></a><a href="https://leetcode.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">Unique Binary Search Trees</a></h2><p><code>给定数字n，求1到n个数字能组成多少种二叉搜索树（BST, Binary Search Tree)？其中1&lt;=n&lt;=19</code></p>
<h3 id="分析求解-2"><a href="#分析求解-2" class="headerlink" title="分析求解"></a>分析求解</h3><p>这道题想了很久，也没想明白怎么用DP解……看题解发现很巧妙也很简单：</p>
<ol>
<li>对于1-n个数，我们从1-n个数里任意拎出来一个数i作为BST根节点。可以得出<center>f(n) = root(1) + root(2) + ... root(n)

</li>
</ol>
<p>其中root(i)代表选第i个数作为BST的根节点时，n个数能组成BST的个数</center></p>
<ol start="2">
<li>BST的性质是：对于根节点，<code>所有的左子树的值都比根节点小，右子树的值都比根节点大</code>。那么当我们拎出i作为根节点时，它的左子树就是1到i-1的数组成的BST，右子树就是i+1到n组成的BST。<br>可以得出 </li>
</ol>
<center>root(m) = sub(1...m-1)*sub(m+1...n)

<p>其中sub(i…j)代表i到j的数字序列能组成的BST的个数</center></p>
<ol start="3">
<li>对于从i到j的连续的自然数，这j-i个数能组成BST的个数和i,j的大小其实没有关系，因为它们之间的大小关系是固定的，而BST的组成依赖的就是数字之间的大小关系，因此同样个数的连续的自然数序列可以组成的BST的个数是相同的。<br>可以得出</li>
</ol>
<center>sub(i...j) = sub(1...j-i+1) = f(j-i+1)

<p>即</p>
<p>root(m) = f(m-1)*f(n-m)</p>
</center>

<ol start="4">
<li>最终得出状态转移方程<center>f(n) = root(1) + root(2) + ... + root(n)

</li>
</ol>
<p>即</p>
<p>f(n) = f(0)<em>f(n-1) + f(1) * f(n-2) + … + f(n-1)</em>f(0)</p>
<p>其中f(0) = 1, 代表子树为空子树</center></p>
<p>我们从1到n一次计算f(n)，用一个数组dp[i]代表f(i)，时间复杂度是O(n*n), 空间复杂度是O(n), 具体实现代码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numTrees</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, n+<span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i&lt;=n; i++ &#123;</span><br><span class="line">        s := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>;j &lt;= i; j++ &#123;</span><br><span class="line">            s += dp[j<span class="number">-1</span>] * dp[i-j]</span><br><span class="line">        &#125; </span><br><span class="line">        dp[i] = s</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Word-Break"><a href="#Word-Break" class="headerlink" title="Word Break"></a><a href="https://leetcode.com/problems/word-break/" target="_blank" rel="noopener">Word Break</a></h2><p><code>给一个字符串和一个单词组成的数组，求这个字符串是否可以划分为只由数组里的词组成，每个词可以使用多次。</code></p>
<h3 id="分析求解-3"><a href="#分析求解-3" class="headerlink" title="分析求解"></a>分析求解</h3><p>思路比较直观，对于字符串s，假如它可以被分成一个满足条件的子串和一个在数组中存在的单词，那么这个字符串就满足题意。即 s = s’ == true &amp;&amp; (s-s’) in dict。对于长度为n的字符串，根据划分的子串的长度可以是1到n-1，我们可以得到状态转移方程：</p>
<center>f(n) = f(0) && c(0...n) || f(1) && c(1...n) || ... || f(-1) && c(n-1...n)

<p>其中c(i…j)代表s的子串s(i:j)是否包含于单词数组。</center></p>
<p>实现代码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wordContain</span><span class="params">(word <span class="keyword">string</span>, wordDict []<span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> wordDict &#123;</span><br><span class="line">		<span class="keyword">if</span> word == v &#123;</span><br><span class="line">			<span class="keyword">return</span>  <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// do[i]代表从0开始长度为i的子串是否是可以wordBreak</span></span><br><span class="line"><span class="comment">// dp[i] = dp[j] &amp;&amp; wordDict.contain(s[j:i]),  j = 0...i-1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wordBreak</span><span class="params">(s <span class="keyword">string</span>, wordDict []<span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(s)</span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="keyword">bool</span>, n+<span class="number">1</span>)</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i&lt;=n; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := i<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j-- &#123;</span><br><span class="line">			<span class="keyword">if</span> dp[j] &amp;&amp; wordContain(s[j:i], wordDict) &#123;</span><br><span class="line">				dp[i] = <span class="literal">true</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Maximum-Product-Subarray"><a href="#Maximum-Product-Subarray" class="headerlink" title="Maximum Product Subarray"></a><a href="https://leetcode.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">Maximum Product Subarray</a></h2><p><code>给定一个整数数组，求其连续子数组的最大乘积。</code></p>
<h3 id="分析求解-4"><a href="#分析求解-4" class="headerlink" title="分析求解"></a>分析求解</h3><p>首先直观思路，对于求字数组nums[0:i]的最大乘积，我们可以先求nums[0:i-1]的最大乘积，nums[0:i]的最大乘积为两情况：</p>
<ol>
<li>nums[i]参与了乘积，即子数组是0…i</li>
<li>仅nums[i]参与了乘积，即子数组是i…i</li>
</ol>
<p>根据最终求得的乘积谁更大来确定。</p>
<p>但是这道题还有一个注意点，由于数组里存在负数，负数会把最大值变为最小值，因此我们需要存储子问题的最大最小值，遇到负数后，需要交换最大最小值来保证正确性即</p>
<ul>
<li>首先我们需要两个变量存储当前的最大、最小乘积，然后遍历数组</li>
<li>当前nums[i]为正数时，乘以最大、最小值来更新</li>
<li>当前nums[i]为负数时，最大最小值会变换符号，所以我们交换最大最小值，然后继续计算</li>
<li>当仅有nums[i]参与的情况，尝试更新最大最小值</li>
</ul>
<p>实现代码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProduct</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    </span><br><span class="line">    res := nums[<span class="number">0</span>]</span><br><span class="line">    max := nums[<span class="number">0</span>]</span><br><span class="line">    min := nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i&lt;n; i++ &#123;</span><br><span class="line">        min = min * nums[i] <span class="comment">// 分别计算当前位置累计乘积的最大和最小乘积</span></span><br><span class="line">        max = max * nums[i] </span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; <span class="number">0</span> &#123; <span class="comment">// 如果nums[i]小于零，交换max和min</span></span><br><span class="line">            min, max = max, min</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; min &#123; </span><br><span class="line">            min = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; max &#123; <span class="comment">// 尝试用当前数单个作为乘积更新累计乘积最大最小值</span></span><br><span class="line">            max = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> max &gt; res &#123; <span class="comment">// 更新res</span></span><br><span class="line">            res = max</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="House-Robber-and-House-Robber-II"><a href="#House-Robber-and-House-Robber-II" class="headerlink" title="House Robber and House Robber II"></a><a href="https://leetcode.com/problems/house-robber/" target="_blank" rel="noopener">House Robber</a> and <a href="https://leetcode.com/problems/house-robber-ii/" target="_blank" rel="noopener">House Robber II</a></h2><p>(这两道题类似所以放在一起写)<br><code>给长度为n的非负整数数组，条件是不能从取相邻的两个数，问取出的数的和最大是多少？</code></p>
<h3 id="分析求解-5"><a href="#分析求解-5" class="headerlink" title="分析求解"></a>分析求解</h3><p>对于数i，有取或者不取两种情况，取的话前一个数就不能取，不取的话就可以取前一个数，因此当我们用f(i)代表前i个数能取到的最大和时，有状态转移方程：</p>
<center>f(i) = max(f(i-2) + nums[i], f(i-1))</center>

<p>一个非常典型的dp，同时由于只依赖f(i-2)和f(i-1)，我们可以只用两个数来存储这两个状态。</p>
<p>实现代码如下：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rob</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123; <span class="keyword">return</span> <span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> &#123; <span class="keyword">return</span> nums[<span class="number">0</span>]&#125;</span><br><span class="line">    </span><br><span class="line">    prepre := nums[<span class="number">0</span>]</span><br><span class="line">    pre := nums[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> prepre &gt; pre &#123;</span><br><span class="line">        pre = prepre</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i&lt;n; i++ &#123;</span><br><span class="line">        t := prepre + nums[i]</span><br><span class="line">        <span class="keyword">if</span> pre &gt; t &#123;</span><br><span class="line">            t = pre</span><br><span class="line">        &#125;</span><br><span class="line">        prepre = pre</span><br><span class="line">        pre = t</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> prepre &gt; pre &#123;</span><br><span class="line">        pre = prepre</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="House-Robber-II"><a href="#House-Robber-II" class="headerlink" title="House Robber II"></a>House Robber II</h3><p>II改为了数组是一个环，第一个数和最后一个数也是相邻的，这里我们只需要加一种情况即是否选第一个数，即从第一个数开始，还是从第二个数开始，然后用上一个题的求解即可，即f(n) = fpre(0) + fpre(1)，<a href="https://leetcode.com/submissions/detail/390717793/" target="_blank" rel="noopener">实现代码</a>就不贴了。。</p>
<h2 id="Maximal-Square"><a href="#Maximal-Square" class="headerlink" title="Maximal Square"></a><a href="https://leetcode.com/problems/maximal-square/" target="_blank" rel="noopener">Maximal Square</a></h2><p><code>一个有0和1组成的二维数组，求其中由全1组成的正方形的最大面积</code></p>
<h3 id="分析求解-6"><a href="#分析求解-6" class="headerlink" title="分析求解"></a>分析求解</h3><p>很直观的DP题，以i,j为正方形的右下角，则它能组成正方形的最大边长等于(i-1,j-1)、(i-1,j)、(i,j-1)的最小值加1，同时遍历时由于只依赖前一行的数据，可以用两个数组来存储状态求解。注意这里由于依赖(i-1,j-1)点，所以没办法优化成一个数组。<br>状态方程如下：</p>
<center>f(i,j) = min(f(i-1,j-1), f(i-1,j), f(i,j-1)) + 1

<p>这里有条件是nums[i][j]为1时</center></p>
<p>实现代码如下:</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maximalSquare</span><span class="params">(matrix [][]<span class="keyword">byte</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(matrix)</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">	m := <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, m+<span class="number">1</span>)</span><br><span class="line">    dp1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, m+<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">	max := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i&lt;= n; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">1</span>; j&lt;= m; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> matrix[i<span class="number">-1</span>][j<span class="number">-1</span>] == <span class="string">'1'</span> &#123;</span><br><span class="line">				t := dp1[j<span class="number">-1</span>]</span><br><span class="line">				<span class="keyword">if</span> dp1[j] &lt; t &#123;</span><br><span class="line">					t = dp1[j]</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> dp[j<span class="number">-1</span>] &lt; t &#123;</span><br><span class="line">					t = dp[j<span class="number">-1</span>]</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				t += <span class="number">1</span></span><br><span class="line">				dp[j] = t</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[j] = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> dp[j] &gt; max &#123;</span><br><span class="line">				max = dp[j]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//dp1 = dp</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j&lt;= m; j++ &#123;</span><br><span class="line">            dp1[j] = dp[j]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> max * max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h3><p>这里有几个不得不说的。。。</p>
<ul>
<li>输入是个byte数组，但是判断的时候用的是’1’字符，我以为是用1，查了好久才查到问题</li>
<li>go没有标准库的min/max函数，确实很蛋疼</li>
<li>我注释的那一行<code>dp1=dp</code>，也是一个坑，go的两个slice赋值时其实是底层数据是共享的，那样直接<code>dp1=dp</code>，修改dp1的值会影响到dp的值，造成子状态错误</li>
</ul>
<h1 id="EOF"><a href="#EOF" class="headerlink" title="EOF"></a>EOF</h1><p>本周的总结完成了，全是DP的题，还是有一些收获，并且在写blog的过程中也会发现一些没有理解透彻的知识点，再接再厉！</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">furthergo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://furthergo.github.io/weekly-algorithm-20200905/">https://furthergo.github.io/weekly-algorithm-20200905/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/algorithm/">algorithm</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/weekly-algorithm-20200912/"><i class="fa fa-chevron-left">  </i><span>[Weekly Algorithm]20200912: Dynamic programming II</span></a></div><div class="next-post pull-right"><a href="/cpu-cache-and-false-sharing/"><span>CPU cache and False sharing</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '5172c31ed5ec5462891c',
  clientSecret: '2a57ab34b48ff0d860dd57f70547e3416ebe0d85',
  repo: 'furthergo.github.io',
  owner: 'furthergo',
  admin: 'furthergo',
  id: md5(decodeURI(location.pathname)),
  language: 'en'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(/img/1.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2020 By furthergo</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.8.2"></script><script src="/js/fancybox.js?version=1.8.2"></script><script src="/js/sidebar.js?version=1.8.2"></script><script src="/js/copy.js?version=1.8.2"></script><script src="/js/fireworks.js?version=1.8.2"></script><script src="/js/transition.js?version=1.8.2"></script><script src="/js/scroll.js?version=1.8.2"></script><script src="/js/head.js?version=1.8.2"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>